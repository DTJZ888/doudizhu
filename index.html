<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>斗地主原型（Supabase）</title>
  <style>
    :root {
      --bg: #f1ecdf;
      --card: rgba(255, 253, 247, 0.88);
      --ink: #211d17;
      --accent: #0e6c43;
      --warn: #96421a;
      --line: #d4cab6;
      --gold: #d6ab42;
      --surface: #f8f3e9;
      --shadow: 0 10px 28px rgba(45, 36, 22, 0.13);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Noto Sans SC", "PingFang SC", "Microsoft YaHei", sans-serif;
      background:
        radial-gradient(circle at 8% -2%, #fff6da 0, transparent 34%),
        radial-gradient(circle at 94% 5%, #fcead7 0, transparent 28%),
        linear-gradient(160deg, #f6f2e8 0%, #efe7d8 100%);
      color: var(--ink);
    }
    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: 16px;
      display: grid;
      gap: 12px;
    }
    .panel {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(5px);
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
    }
    h1 { margin: 0; font-size: 20px; }
    h2 { margin: 0 0 8px; font-size: 16px; }
    input, button {
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 14px;
      background: #fff;
      color: var(--ink);
    }
    button {
      cursor: pointer;
      background: #f7f3ea;
      transition: transform .15s ease, box-shadow .15s ease, background .15s ease;
    }
    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 5px 14px rgba(38, 30, 18, .16);
      background: #fff9ee;
    }
    button.primary { border-color: #115f3b; background: var(--accent); color: #fff; }
    button.warn { border-color: #82370f; background: var(--warn); color: #fff; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 12px;
    }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .small { font-size: 12px; color: #5b554c; }
    .muted { color: #6f675d; }
    .seats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap: 8px;
    }
    .seat {
      border: 1px dashed #ccbfa8;
      border-radius: 12px;
      padding: 10px;
      min-height: 108px;
      background: linear-gradient(180deg, #fffdfa 0%, #faf5ec 100%);
    }
    .seat.you {
      border-color: #1a7a4c;
      background: linear-gradient(180deg, #eefbf3 0%, #e4f3ea 100%);
    }
    .pill {
      display: inline-block;
      border: 1px solid #cdbf9f;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 12px;
      margin-right: 6px;
      background: #fff9ec;
    }
    #handCards {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      min-height: 48px;
    }
    .card-btn {
      border: 1px solid #cbbda4;
      border-radius: 10px;
      background: linear-gradient(180deg, #fff 0%, #f8f4ea 100%);
      min-width: 52px;
      padding: 8px 10px;
      font-weight: 600;
      box-shadow: 0 4px 10px rgba(53, 43, 26, .12);
    }
    .card-btn:hover:not(:disabled) {
      transform: translateY(-3px);
      box-shadow: 0 8px 18px rgba(42, 33, 19, .18);
    }
    .red { color: #b61f1f; }
    .log {
      max-height: 180px;
      overflow: auto;
      margin: 0;
      padding-left: 18px;
    }
    .log li { margin-bottom: 4px; }
    .ok { color: #126842; }
    .err { color: #9e3316; }
    .hero-note {
      margin-top: 6px;
      padding: 8px 10px;
      border-radius: 10px;
      background: linear-gradient(90deg, #fff7e4 0%, #f8efd9 100%);
      border: 1px solid #e2d2b3;
      color: #6a5731;
      font-size: 12px;
    }
    .seat.turning {
      border-color: #d0972f;
      box-shadow: 0 0 0 2px rgba(213, 158, 46, .16) inset;
    }
    @media (max-width: 680px) {
      h1 { font-size: 17px; }
      .wrap { padding: 12px; }
      .panel { padding: 12px; }
      .card-btn { min-width: 48px; padding: 7px 8px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div class="row" style="justify-content: space-between;">
        <h1>斗地主原型（Supabase，非 Google 依赖）</h1>
        <div id="authStatus" class="small">登录中...</div>
      </div>
      <div class="hero-note">房间上限 9 人，支持 2-4 人对局。当前是原型规则：单牌比较，重点验证联机流程与手感。</div>
    </div>

    <div class="panel">
      <h2>大厅</h2>
      <div class="row">
        <label>昵称</label>
        <input id="nicknameInput" maxlength="12" placeholder="输入昵称" />
        <button id="saveNickBtn">保存昵称</button>
      </div>
      <div class="row" style="margin-top: 8px;">
        <button id="createRoomBtn" class="primary">创建房间</button>
        <input id="roomCodeInput" maxlength="8" placeholder="输入房间码" class="mono" />
        <button id="joinRoomBtn">加入房间</button>
      </div>
      <div class="row" style="margin-top: 8px;">
        <span>当前房间：</span>
        <span id="roomCodeLabel" class="mono">-</span>
        <button id="copyLinkBtn">复制邀请链接</button>
        <button id="leaveRoomBtn" class="warn">离开房间</button>
      </div>
      <div id="lobbyMsg" class="small muted" style="margin-top: 8px;"></div>
    </div>

    <div class="grid">
      <div class="panel">
        <h2>房间与座位</h2>
        <div id="roomInfo" class="small">尚未加入房间</div>
        <div class="seats" id="seatsWrap" style="margin-top: 8px;"></div>
        <div class="row" style="margin-top: 8px;">
          <button id="toggleReadyBtn">准备</button>
          <button id="startBtn" class="primary">开始游戏</button>
          <button id="hostTakeoverBtn">接管房主</button>
        </div>
      </div>

      <div class="panel">
        <h2>游戏</h2>
        <div id="gameInfo" class="small">等待开局</div>
        <div class="row" id="bidWrap" style="margin-top: 8px; display: none;">
          <span>叫分：</span>
          <button data-bid="0">不叫</button>
          <button data-bid="1">1分</button>
          <button data-bid="2">2分</button>
          <button data-bid="3">3分</button>
        </div>
        <div class="row" id="playActions" style="margin-top: 8px; display: none;">
          <button id="passBtn">过牌</button>
        </div>
        <div style="margin-top: 8px;">
          <div class="small">你的手牌</div>
          <div id="handCards"></div>
        </div>
      </div>

      <div class="panel">
        <h2>事件日志</h2>
        <ul id="eventLog" class="log small"></ul>
      </div>
    </div>
  </div>

  <script type="module">
    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

    // 替换为 Supabase 项目配置。
    // 也可在页面外注入: window.SUPABASE_CONFIG = { url, publishableKey }
    const supabaseConfig = window.SUPABASE_CONFIG || {
      url: "https://eavgvsmklualdetrrznf.supabase.co",
      publishableKey: "sb_publishable_hl2JO9TOrGCldYEIitM0qA_7o6XNek_"
    };

    const TABLE_MIN_PLAYERS = 2;
    const TABLE_MAX_PLAYERS = 4;
    const TABLE_SEAT_COUNT = 4;

    const state = {
      uid: "",
      nick: localStorage.getItem("ddz_nick") || `玩家${Math.floor(Math.random() * 9000 + 1000)}`,
      roomId: "",
      room: null,
      hand: {},
      logs: [],
      roomUnsubs: [],
      authUnsub: null,
      pollTimer: null,
      realtimeReady: false
    };

    const authStatus = document.getElementById("authStatus");
    const nicknameInput = document.getElementById("nicknameInput");
    const saveNickBtn = document.getElementById("saveNickBtn");
    const createRoomBtn = document.getElementById("createRoomBtn");
    const roomCodeInput = document.getElementById("roomCodeInput");
    const joinRoomBtn = document.getElementById("joinRoomBtn");
    const roomCodeLabel = document.getElementById("roomCodeLabel");
    const copyLinkBtn = document.getElementById("copyLinkBtn");
    const leaveRoomBtn = document.getElementById("leaveRoomBtn");
    const lobbyMsg = document.getElementById("lobbyMsg");
    const roomInfo = document.getElementById("roomInfo");
    const seatsWrap = document.getElementById("seatsWrap");
    const toggleReadyBtn = document.getElementById("toggleReadyBtn");
    const startBtn = document.getElementById("startBtn");
    const hostTakeoverBtn = document.getElementById("hostTakeoverBtn");
    const gameInfo = document.getElementById("gameInfo");
    const bidWrap = document.getElementById("bidWrap");
    const playActions = document.getElementById("playActions");
    const passBtn = document.getElementById("passBtn");
    const handCards = document.getElementById("handCards");
    const eventLog = document.getElementById("eventLog");

    nicknameInput.value = state.nick;

    function log(msg) {
      const now = new Date().toLocaleTimeString();
      state.logs.unshift(`[${now}] ${msg}`);
      state.logs = state.logs.slice(0, 60);
      eventLog.innerHTML = state.logs.map((x) => `<li>${escapeHtml(x)}</li>`).join("");
    }

    function showMsg(msg, isErr = false) {
      lobbyMsg.className = `small ${isErr ? "err" : "ok"}`;
      lobbyMsg.textContent = msg;
    }

    function escapeHtml(str) {
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function clone(obj) {
      if (typeof structuredClone === "function") return structuredClone(obj);
      return JSON.parse(JSON.stringify(obj));
    }

    function randRoomCode() {
      const chars = "ABCDEFGHJKMNPQRSTUVWXYZ23456789";
      let code = "";
      for (let i = 0; i < 6; i += 1) code += chars[Math.floor(Math.random() * chars.length)];
      return code;
    }

    function friendlyErr(err) {
      if (!err) return "未知错误";
      const code = String(err.code || "");
      const msg = String(err.message || "");
      const raw = `${code} ${msg}`;
      if (raw.includes("Anonymous") || raw.includes("anonymous")) return "匿名登录未开启（Supabase Auth -> Anonymous Sign-Ins）";
      if (raw.includes("Invalid API key") || raw.includes("JWT") || raw.includes("apikey")) return "Supabase publishable key 无效";
      if (raw.includes("NetworkError") || raw.includes("Failed to fetch")) return "网络异常，无法连接 Supabase";
      if (raw.includes("permission") || raw.includes("policy")) return "数据库权限不足（请检查 RLS 策略）";
      if (raw.includes("23505")) return "房间码冲突，请重试";
      return code || msg || "未知错误";
    }

    const supabaseKey = supabaseConfig.publishableKey || supabaseConfig.anonKey || "REPLACE_ME";

    function isConfigReady() {
      return !!supabaseConfig.url
        && !!supabaseKey
        && supabaseConfig.url !== "REPLACE_ME"
        && supabaseKey !== "REPLACE_ME";
    }

    const supabase = isConfigReady()
      ? createClient(supabaseConfig.url, supabaseKey, {
        auth: { persistSession: true, autoRefreshToken: true }
      })
      : null;

    function buildSeatIndexes(seatCount = TABLE_SEAT_COUNT) {
      const n = Math.max(TABLE_MIN_PLAYERS, Math.min(TABLE_SEAT_COUNT, Number(seatCount) || TABLE_SEAT_COUNT));
      return Array.from({ length: n }, (_, i) => i);
    }

    function activeSeatsFrom(seats, seatCount = TABLE_SEAT_COUNT) {
      return buildSeatIndexes(seatCount).filter((seat) => !!seats?.[String(seat)]);
    }

    function getBottomCardCount(playerCount) {
      if (playerCount === 3) return 3;
      if (playerCount === 2 || playerCount === 4) return 2;
      return 2;
    }

    function ensureRoomStateShape(work) {
      work.state = work.state || {};
      work.state.members = work.state.members || {};
      work.state.seatCount = Math.max(
        TABLE_MIN_PLAYERS,
        Math.min(TABLE_SEAT_COUNT, Number(work.state.seatCount) || TABLE_SEAT_COUNT)
      );
      work.state.seats = work.state.seats || {};
      for (const seat of buildSeatIndexes(work.state.seatCount)) {
        const key = String(seat);
        if (!(key in work.state.seats)) work.state.seats[key] = null;
      }
      work.state.ready = work.state.ready || {};
      work.state.publicCounts = work.state.publicCounts || {};
      if (typeof work.max_members !== "number") work.max_members = 9;
    }

    function mapRoomRow(row) {
      if (!row) return null;
      const s = clone(row.state || {});
      return {
        id: row.room_id,
        hostUid: row.host_uid,
        maxMembers: row.max_members || 9,
        status: row.status,
        seatCount: s.seatCount || TABLE_SEAT_COUNT,
        members: s.members || {},
        seats: s.seats || {},
        ready: s.ready || {},
        publicCounts: s.publicCounts || {},
        game: s.game || null,
        revision: row.revision
      };
    }

    function getMySeat(room) {
      if (!room || !room.seats || !state.uid) return null;
      for (const [seat, uid] of Object.entries(room.seats)) {
        if (uid === state.uid) return Number(seat);
      }
      return null;
    }

    function nextSeat(activeSeats, cur) {
      if (!activeSeats.length) return cur;
      const idx = activeSeats.indexOf(cur);
      if (idx === -1) return activeSeats[0];
      return activeSeats[(idx + 1) % activeSeats.length];
    }

    function makeDeck() {
      const suits = ["S", "H", "C", "D"];
      const ranks = ["3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A", "2"];
      const rankPower = {
        "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8,
        "9": 9, "10": 10, J: 11, Q: 12, K: 13, A: 14, "2": 16
      };
      const deck = [];
      for (const r of ranks) {
        for (const s of suits) {
          const id = `${r}${s}`;
          deck.push({
            id,
            rank: r,
            suit: s,
            power: rankPower[r],
            label: `${r}${s}`,
            red: s === "H" || s === "D"
          });
        }
      }
      deck.push({ id: "SJ", rank: "SJ", suit: "", power: 18, label: "小王", red: false });
      deck.push({ id: "BJ", rank: "BJ", suit: "", power: 20, label: "大王", red: true });
      return deck;
    }

    function shuffle(arr) {
      const a = [...arr];
      const rnd = new Uint32Array(a.length);
      crypto.getRandomValues(rnd);
      for (let i = a.length - 1; i > 0; i -= 1) {
        const j = rnd[i] % (i + 1);
        const tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
      }
      return a;
    }

    function sortedHandCards(handMap) {
      const cards = Object.values(handMap || {});
      cards.sort((a, b) => {
        if (a.power !== b.power) return a.power - b.power;
        return a.label.localeCompare(b.label);
      });
      return cards;
    }

    async function fetchRoomOnce() {
      if (!supabase || !state.roomId) return;
      const { data, error } = await supabase
        .from("rooms")
        .select("*")
        .eq("room_id", state.roomId)
        .maybeSingle();

      if (error) {
        showMsg(`拉取房间失败：${friendlyErr(error)}`, true);
        return;
      }

      if (!data) {
        showMsg("房间不存在或已解散", true);
        detachRoomListeners();
        state.roomId = "";
        state.room = null;
        state.hand = {};
        roomCodeLabel.textContent = "-";
        history.replaceState({}, "", location.pathname);
        render();
        return;
      }

      state.room = mapRoomRow(data);
      await cleanupGhostSeats();
      await autoFixHost();
      await hostGrantBottomIfNeeded();
    }

    async function fetchHandOnce() {
      if (!supabase || !state.roomId || !state.uid) return;
      const { data, error } = await supabase
        .from("private_hands")
        .select("uid,cards")
        .eq("room_id", state.roomId)
        .eq("uid", state.uid)
        .maybeSingle();

      if (error && error.code !== "PGRST116") {
        showMsg(`拉取手牌失败：${friendlyErr(error)}`, true);
        return;
      }

      state.hand = data?.cards || {};
    }

    async function refreshRoomAndHand() {
      if (!state.roomId) return;
      await Promise.all([fetchRoomOnce(), fetchHandOnce()]);
      render();
    }

    function detachRoomListeners() {
      if (state.pollTimer) {
        clearInterval(state.pollTimer);
        state.pollTimer = null;
      }
      for (const fn of state.roomUnsubs) fn();
      state.roomUnsubs = [];
      state.realtimeReady = false;
    }

    function attachRoomListeners() {
      detachRoomListeners();
      if (!state.roomId || !supabase) return;

      refreshRoomAndHand();
      state.pollTimer = setInterval(refreshRoomAndHand, 1500);

      const channel = supabase
        .channel(`room-${state.roomId}-${Date.now()}`)
        .on(
          "postgres_changes",
          { event: "*", schema: "public", table: "rooms", filter: `room_id=eq.${state.roomId}` },
          async () => {
            await fetchRoomOnce();
            render();
          }
        )
        .on(
          "postgres_changes",
          { event: "*", schema: "public", table: "private_hands", filter: `room_id=eq.${state.roomId}` },
          async (payload) => {
            const row = payload.new || payload.old;
            if (!row || row.uid !== state.uid) return;
            await fetchHandOnce();
            render();
          }
        )
        .subscribe((status) => {
          if (status === "SUBSCRIBED") {
            state.realtimeReady = true;
          }
        });

      state.roomUnsubs.push(() => {
        supabase.removeChannel(channel);
      });
    }

    async function mutateRoom(rid, mutator, retries = 8) {
      if (!supabase || !rid) return { committed: false, reason: "bad_request" };

      for (let i = 0; i < retries; i += 1) {
        const { data: row, error: selErr } = await supabase
          .from("rooms")
          .select("*")
          .eq("room_id", rid)
          .maybeSingle();

        if (selErr) throw selErr;
        if (!row) return { committed: false, reason: "not_found" };

        const work = {
          room_id: row.room_id,
          host_uid: row.host_uid,
          status: row.status,
          max_members: row.max_members,
          state: clone(row.state || {}),
          revision: row.revision
        };

        ensureRoomStateShape(work);
        const action = mutator(work);

        if (action === false) return { committed: false, reason: "rejected" };

        if (action === null) {
          const { data: deleted, error: delErr } = await supabase
            .from("rooms")
            .delete()
            .eq("room_id", rid)
            .eq("revision", row.revision)
            .select("room_id");

          if (delErr) throw delErr;
          if (deleted && deleted.length === 1) return { committed: true, deleted: true };
          continue;
        }

        const patch = {
          host_uid: work.host_uid,
          status: work.status,
          max_members: work.max_members,
          state: work.state,
          revision: row.revision + 1,
          updated_at: new Date().toISOString()
        };

        const { data: updated, error: upErr } = await supabase
          .from("rooms")
          .update(patch)
          .eq("room_id", rid)
          .eq("revision", row.revision)
          .select("room_id");

        if (upErr) throw upErr;
        if (updated && updated.length === 1) return { committed: true };
      }

      return { committed: false, reason: "conflict" };
    }

    async function createRoom() {
      if (!supabase) {
        showMsg("请先填写 SUPABASE_CONFIG", true);
        return;
      }
      if (state.roomId) {
        showMsg("请先离开当前房间", true);
        return;
      }
      if (!state.uid) {
        showMsg("尚未登录，请稍后再试", true);
        return;
      }

      try {
        for (let i = 0; i < 8; i += 1) {
          const code = randRoomCode();
          const row = {
            room_id: code,
            host_uid: state.uid,
            max_members: 9,
            status: "lobby",
            revision: 1,
            state: {
              members: {
                [state.uid]: {
                  nick: state.nick,
                  joinedAt: Date.now()
                }
              },
              seatCount: TABLE_SEAT_COUNT,
              seats: { "0": null, "1": null, "2": null, "3": null },
              ready: {},
              publicCounts: {},
              game: null
            }
          };

          const { data, error } = await supabase
            .from("rooms")
            .insert(row)
            .select("room_id");

          if (error) {
            if (error.code === "23505") continue;
            throw error;
          }

          if (data && data.length === 1) {
            state.roomId = code;
            roomCodeInput.value = code;
            roomCodeLabel.textContent = code;
            history.replaceState({}, "", `${location.pathname}?room=${encodeURIComponent(code)}`);
            attachRoomListeners();
            showMsg(`已创建并加入房间 ${code}`);
            log(`已创建房间 ${code}`);
            return;
          }
        }
        showMsg("创建失败：房间码冲突，请重试", true);
      } catch (err) {
        showMsg(`创建失败：${friendlyErr(err)}`, true);
        log(`创建房间异常：${friendlyErr(err)}`);
      }
    }

    async function joinRoom(roomId) {
      if (!supabase) {
        showMsg("请先填写 SUPABASE_CONFIG", true);
        return;
      }
      if (state.roomId) {
        showMsg("请先离开当前房间", true);
        return;
      }
      if (!state.uid) {
        showMsg("尚未登录，请稍后再试", true);
        return;
      }

      const code = (roomId || "").trim().toUpperCase();
      if (!code) {
        showMsg("请输入房间码", true);
        return;
      }

      try {
        const result = await mutateRoom(code, (room) => {
          ensureRoomStateShape(room);
          const members = room.state.members;
          const size = Object.keys(members).length;
          if (!members[state.uid] && size >= room.max_members) return false;
          members[state.uid] = {
            nick: state.nick,
            joinedAt: members[state.uid]?.joinedAt || Date.now()
          };
        });

        if (!result.committed) {
          showMsg("加入失败：房间不存在或已满（最多 9 人）", true);
          return;
        }

        state.roomId = code;
        roomCodeInput.value = code;
        roomCodeLabel.textContent = code;
        history.replaceState({}, "", `${location.pathname}?room=${encodeURIComponent(code)}`);
        attachRoomListeners();
        showMsg("已加入房间");
        log(`已进入房间 ${code}`);
      } catch (err) {
        showMsg(`加入失败：${friendlyErr(err)}`, true);
        log(`加入房间异常：${friendlyErr(err)}`);
      }
    }

    async function leaveRoom() {
      if (!supabase || !state.roomId || !state.uid) return;
      const rid = state.roomId;

      try {
        await mutateRoom(rid, (room) => {
          ensureRoomStateShape(room);
          const members = room.state.members;
          if (!members[state.uid]) return false;

          delete members[state.uid];
          delete room.state.ready[state.uid];
          delete room.state.publicCounts[state.uid];

          for (const s of buildSeatIndexes(room.state.seatCount)) {
            const key = String(s);
            if (room.state.seats[key] === state.uid) room.state.seats[key] = null;
          }

          const left = Object.keys(members);
          if (!left.length) return null;

          if (!members[room.host_uid]) {
            let nextHost = left[0];
            for (const uid of left) {
              const a = members[nextHost]?.joinedAt || Number.MAX_SAFE_INTEGER;
              const b = members[uid]?.joinedAt || Number.MAX_SAFE_INTEGER;
              if (b < a) nextHost = uid;
            }
            room.host_uid = nextHost;
          }
        });

        await supabase
          .from("private_hands")
          .delete()
          .eq("room_id", rid)
          .eq("uid", state.uid);
      } catch (err) {
        showMsg(`离开房间异常：${friendlyErr(err)}`, true);
      }

      detachRoomListeners();
      state.roomId = "";
      state.room = null;
      state.hand = {};
      roomCodeLabel.textContent = "-";
      history.replaceState({}, "", location.pathname);
      showMsg("已离开房间");
      render();
    }

    async function cleanupGhostSeats() {
      if (!state.room || !state.roomId) return;
      const room = state.room;
      const members = room.members || {};
      const seats = room.seats || {};
      let needFix = false;

      for (const s of buildSeatIndexes(room.seatCount)) {
        const uid = seats[String(s)];
        if (uid && !members[uid]) {
          needFix = true;
          break;
        }
      }
      if (!needFix) return;

      await mutateRoom(state.roomId, (work) => {
        ensureRoomStateShape(work);
        for (const s of buildSeatIndexes(work.state.seatCount)) {
          const key = String(s);
          const uid = work.state.seats[key];
          if (uid && !work.state.members[uid]) {
            work.state.seats[key] = null;
            delete work.state.ready[uid];
            delete work.state.publicCounts[uid];
          }
        }
      });
    }

    async function autoFixHost() {
      if (!state.room || !state.roomId) return;
      if (state.room.members?.[state.room.hostUid]) return;
      if (!state.room.members?.[state.uid]) return;
      await takeHost();
    }

    async function seatAction(targetSeat) {
      if (!state.roomId) return;
      await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (room.status !== "lobby") return false;
        if (!room.state.members[state.uid]) return false;

        for (const s of buildSeatIndexes(room.state.seatCount)) {
          const key = String(s);
          if (room.state.seats[key] === state.uid) room.state.seats[key] = null;
        }

        if (targetSeat !== null) {
          const key = String(targetSeat);
          if (room.state.seats[key]) return false;
          room.state.seats[key] = state.uid;
        }
      });
    }

    async function toggleReady() {
      if (!state.roomId) return;
      await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (room.status !== "lobby") return false;
        const mySeat = getMySeat(mapRoomRow(room));
        if (mySeat === null) return false;
        room.state.ready[state.uid] = !room.state.ready[state.uid];
      });
    }

    async function takeHost() {
      if (!state.roomId) return;
      await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (!room.state.members[state.uid]) return false;
        if (room.state.members[room.host_uid]) return false;
        room.host_uid = state.uid;
      });
    }

    async function writeHand(uid, cards) {
      if (!supabase || !state.roomId) return;
      const { error } = await supabase
        .from("private_hands")
        .upsert({
          room_id: state.roomId,
          uid,
          cards,
          updated_at: new Date().toISOString()
        }, { onConflict: "room_id,uid" });
      if (error) throw error;
    }

    async function startGame() {
      if (!state.roomId || !state.room) return;
      if (state.room.hostUid !== state.uid || state.room.status !== "lobby") return;

      let activeSeats = [];
      let seatUids = [];
      let hands = null;
      const deck = shuffle(makeDeck());
      let bottom = [];

      const tx = await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (room.host_uid !== state.uid || room.status !== "lobby") return false;

        activeSeats = activeSeatsFrom(room.state.seats, room.state.seatCount);
        if (activeSeats.length < TABLE_MIN_PLAYERS || activeSeats.length > TABLE_MAX_PLAYERS) return false;

        seatUids = activeSeats.map((seat) => room.state.seats[String(seat)]);
        if (seatUids.some((uid) => !room.state.ready[uid])) return false;

        const bottomCount = getBottomCardCount(activeSeats.length);
        const dealCount = deck.length - bottomCount;
        bottom = deck.slice(dealCount);

        hands = Object.fromEntries(seatUids.map((uid) => [uid, {}]));
        room.state.publicCounts = Object.fromEntries(seatUids.map((uid) => [uid, 0]));

        for (let i = 0; i < dealCount; i += 1) {
          const uid = seatUids[i % seatUids.length];
          hands[uid][deck[i].id] = deck[i];
          room.state.publicCounts[uid] += 1;
        }

        const startSeat = activeSeats[0];
        const bidMap = Object.fromEntries(activeSeats.map((seat) => [String(seat), null]));

        const round = ((room.state.game && room.state.game.round) || 0) + 1;
        room.status = "bidding";
        room.state.game = {
          round,
          activeSeats,
          bid: {
            currentSeat: startSeat,
            acted: 0,
            bids: bidMap,
            highestBid: 0,
            highestSeat: null
          },
          landlordSeat: null,
          bottomCards: bottom,
          bottomClaimed: false,
          turnSeat: startSeat,
          trickLeaderSeat: null,
          passNeed: Math.max(activeSeats.length - 1, 1),
          passStreak: 0,
          lastPlay: null,
          winnerSeat: null,
          updatedAt: Date.now()
        };

        room.state.ready = {};
      });

      if (!tx.committed) return;
      if (!seatUids.length || !hands) return;

      try {
        await Promise.all(seatUids.map((uid) => writeHand(uid, hands[uid])));
        log("发牌完成，进入叫分阶段");
      } catch (err) {
        showMsg(`发牌写入失败：${friendlyErr(err)}`, true);
      }
    }

    async function bid(points) {
      const bidVal = Number(points);
      if (![0, 1, 2, 3].includes(bidVal)) return;
      if (!state.roomId) return;

      await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (room.status !== "bidding" || !room.state.game || !room.state.game.bid) return false;

        const mySeat = getMySeat(mapRoomRow(room));
        if (mySeat === null) return false;

        const b = room.state.game.bid;
        if (b.currentSeat !== mySeat) return false;
        if (b.bids[String(mySeat)] !== null) return false;

        b.bids[String(mySeat)] = bidVal;
        b.acted += 1;

        if (bidVal > b.highestBid) {
          b.highestBid = bidVal;
          b.highestSeat = mySeat;
        }

        const activeSeats = (room.state.game.activeSeats || activeSeatsFrom(room.state.seats, room.state.seatCount))
          .filter((seat) => !!room.state.seats[String(seat)]);
        const done = b.acted >= activeSeats.length || bidVal === 3;
        if (!done) {
          b.currentSeat = nextSeat(activeSeats, mySeat);
          room.state.game.updatedAt = Date.now();
          return;
        }

        const landlordSeat = b.highestSeat === null ? activeSeats[0] : b.highestSeat;
        room.state.game.landlordSeat = landlordSeat;
        room.status = "playing";
        room.state.game.turnSeat = landlordSeat;
        room.state.game.trickLeaderSeat = landlordSeat;
        room.state.game.passNeed = Math.max(activeSeats.length - 1, 1);
        room.state.game.passStreak = 0;
        room.state.game.lastPlay = null;
        room.state.game.bottomClaimed = false;
        room.state.game.updatedAt = Date.now();
      });
    }

    async function hostGrantBottomIfNeeded() {
      const room = state.room;
      if (!room || !state.roomId) return;
      if (room.hostUid !== state.uid) return;
      if (room.status !== "playing" || !room.game || room.game.bottomClaimed) return;

      const landlordSeat = room.game.landlordSeat;
      const landlordUid = room.seats?.[String(landlordSeat)];
      const bottom = room.game.bottomCards || [];
      if (!landlordUid || !bottom.length) return;

      const tx = await mutateRoom(state.roomId, (work) => {
        ensureRoomStateShape(work);
        if (work.host_uid !== state.uid) return false;
        if (work.status !== "playing" || !work.state.game || work.state.game.bottomClaimed) return false;

        const seat = work.state.game.landlordSeat;
        const uid = work.state.seats[String(seat)];
        if (!uid) return false;

        work.state.publicCounts[uid] = (work.state.publicCounts[uid] || 0) + (work.state.game.bottomCards || []).length;
        work.state.game.bottomClaimed = true;
        work.state.game.updatedAt = Date.now();
      });

      if (!tx.committed) return;

      const { data: handRow } = await supabase
        .from("private_hands")
        .select("cards")
        .eq("room_id", state.roomId)
        .eq("uid", landlordUid)
        .maybeSingle();

      const merged = clone(handRow?.cards || {});
      for (const c of bottom) merged[c.id] = c;
      await writeHand(landlordUid, merged);
    }

    async function playCard(cardId) {
      if (!state.roomId || !state.room) return;
      const card = state.hand?.[cardId];
      if (!card) return;

      const nextHand = clone(state.hand);
      delete nextHand[cardId];

      try {
        await writeHand(state.uid, nextHand);
      } catch (err) {
        showMsg(`手牌更新失败：${friendlyErr(err)}`, true);
        return;
      }

      const roomTx = await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (room.status !== "playing" || !room.state.game || !room.state.game.bottomClaimed) return false;

        const mySeat = getMySeat(mapRoomRow(room));
        if (mySeat === null || room.state.game.turnSeat !== mySeat) return false;

        const lastPlay = room.state.game.lastPlay;
        if (lastPlay && room.state.game.trickLeaderSeat !== mySeat && card.power <= lastPlay.power) return false;

        room.state.publicCounts[state.uid] = Math.max((room.state.publicCounts[state.uid] || 0) - 1, 0);

        room.state.game.lastPlay = {
          seat: mySeat,
          uid: state.uid,
          cardId: card.id,
          label: card.label,
          power: card.power
        };
        room.state.game.trickLeaderSeat = mySeat;
        room.state.game.passStreak = 0;

        if (room.state.publicCounts[state.uid] === 0) {
          room.status = "finished";
          room.state.game.winnerSeat = mySeat;
          room.state.game.updatedAt = Date.now();
          return;
        }

        const liveSeats = (room.state.game.activeSeats || []).filter((seat) => !!room.state.seats[String(seat)]);
        room.state.game.turnSeat = nextSeat(liveSeats, mySeat);
        room.state.game.updatedAt = Date.now();
      });

      if (!roomTx.committed) {
        const rollback = clone(nextHand);
        rollback[cardId] = card;
        await writeHand(state.uid, rollback);
        showMsg("出牌失败，已回滚手牌", true);
      }
    }

    async function pass() {
      if (!state.roomId) return;
      await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (room.status !== "playing" || !room.state.game || !room.state.game.bottomClaimed) return false;

        const mySeat = getMySeat(mapRoomRow(room));
        if (mySeat === null || room.state.game.turnSeat !== mySeat) return false;
        if (!room.state.game.lastPlay) return false;
        if (room.state.game.trickLeaderSeat === mySeat) return false;

        room.state.game.passStreak += 1;
        const liveSeats = (room.state.game.activeSeats || []).filter((seat) => !!room.state.seats[String(seat)]);
        const passNeed = room.state.game.passNeed || Math.max(liveSeats.length - 1, 1);

        if (room.state.game.passStreak >= passNeed) {
          room.state.game.turnSeat = room.state.game.trickLeaderSeat;
          room.state.game.lastPlay = null;
          room.state.game.passStreak = 0;
        } else {
          room.state.game.turnSeat = nextSeat(liveSeats, mySeat);
        }
        room.state.game.updatedAt = Date.now();
      });
    }

    function nameOf(uid) {
      const m = state.room?.members?.[uid];
      return m?.nick || uid?.slice(0, 6) || "-";
    }

    function renderSeats() {
      const room = state.room;
      if (!room) {
        seatsWrap.innerHTML = "";
        return;
      }

      const mySeat = getMySeat(room);
      const seatIndexes = buildSeatIndexes(room.seatCount);
      seatsWrap.innerHTML = seatIndexes.map((seat) => {
        const uid = room.seats?.[String(seat)] || null;
        const isMine = uid && uid === state.uid;
        const label = uid ? escapeHtml(nameOf(uid)) : "空位";
        const ready = uid && room.ready?.[uid] ? "<span class='pill'>已准备</span>" : "";
        const landlord = room.game?.landlordSeat === seat ? "<span class='pill'>地主</span>" : "";
        const turn = room.game?.turnSeat === seat && room.status === "playing" ? "<span class='pill'>出牌中</span>" : "";
        const count = uid ? `<div class='small'>剩余牌：${room.publicCounts?.[uid] ?? "-"}</div>` : "";
        const btn = uid
          ? (isMine ? `<button data-seat='stand'>离座</button>` : "")
          : `<button data-seat='${seat}'>入座</button>`;
        const turnClass = room.game?.turnSeat === seat && room.status === "playing" ? "turning" : "";

        return `
          <div class="seat ${mySeat === seat ? "you" : ""} ${turnClass}">
            <div><strong>${seat + 1} 号位</strong></div>
            <div style="margin-top: 4px;">${label}</div>
            <div style="margin-top: 6px;">${ready}${landlord}${turn}</div>
            <div style="margin-top: 6px;">${count}</div>
            <div style="margin-top: 8px;">${btn}</div>
          </div>
        `;
      }).join("");

      seatsWrap.querySelectorAll("button[data-seat]").forEach((btn) => {
        btn.addEventListener("click", async () => {
          const v = btn.dataset.seat;
          if (v === "stand") {
            await seatAction(null);
            return;
          }
          await seatAction(Number(v));
        });
      });
    }

    function renderRoomInfo() {
      if (!state.room) {
        roomInfo.innerHTML = "尚未加入房间";
        return;
      }

      const room = state.room;
      const members = Object.entries(room.members || {}).sort((a, b) => (a[1].joinedAt || 0) - (b[1].joinedAt || 0));
      const seated = activeSeatsFrom(room.seats, room.seatCount).length;
      roomInfo.innerHTML = `
        <div>状态：<span class="pill">${escapeHtml(room.status || "-")}</span></div>
        <div>房主：${escapeHtml(nameOf(room.hostUid))}</div>
        <div>在线人数：${members.length}/${room.maxMembers || 9}</div>
        <div>入座人数：${seated}（可开局范围：${TABLE_MIN_PLAYERS}-${TABLE_MAX_PLAYERS}）</div>
        <div>同步：${state.realtimeReady ? "实时通道" : "轮询"}</div>
        <div style="margin-top: 6px;">成员：${members.map(([uid, v]) => {
          const host = uid === room.hostUid ? "(房主)" : "";
          return `${escapeHtml(v.nick || uid.slice(0, 6))}${host}`;
        }).join("、")}</div>
      `;
    }

    function renderGame() {
      const room = state.room;
      if (!room || !room.game) {
        gameInfo.textContent = "等待开局";
        bidWrap.style.display = "none";
        playActions.style.display = "none";
        return;
      }

      const mySeat = getMySeat(room);
      const game = room.game;

      if (room.status === "bidding") {
        const curUid = room.seats?.[String(game.bid.currentSeat)];
        const bids = game.bid.bids || {};
        const bidLabels = (game.activeSeats || []).map((seat) => `${seat + 1}号(${bids[String(seat)] ?? "-"})`).join(" / ");
        gameInfo.innerHTML = `
          <div>阶段：叫分</div>
          <div>当前：${escapeHtml(nameOf(curUid))}</div>
          <div>叫分记录：${escapeHtml(bidLabels || "-")}</div>
        `;
        bidWrap.style.display = mySeat === game.bid.currentSeat ? "flex" : "none";
        playActions.style.display = "none";
      } else if (room.status === "playing") {
        const last = game.lastPlay ? `${game.lastPlay.label}（${nameOf(game.lastPlay.uid)}）` : "无（新一轮）";
        const landlordUid = room.seats?.[String(game.landlordSeat)];
        const turnUid = room.seats?.[String(game.turnSeat)];
        gameInfo.innerHTML = `
          <div>阶段：出牌</div>
          <div>地主：${escapeHtml(nameOf(landlordUid))}</div>
          <div>当前：${escapeHtml(nameOf(turnUid))}</div>
          <div>最近牌：${escapeHtml(last)}</div>
          <div>底牌状态：${game.bottomClaimed ? "已发放" : "房主发放中"}</div>
        `;
        bidWrap.style.display = "none";
        playActions.style.display = mySeat === game.turnSeat && game.bottomClaimed ? "flex" : "none";
      } else if (room.status === "finished") {
        const winnerUid = room.seats?.[String(game.winnerSeat)];
        gameInfo.innerHTML = `
          <div>阶段：已结束</div>
          <div>胜者：${escapeHtml(nameOf(winnerUid))}</div>
          <div class="small">房主可重新开始（${TABLE_MIN_PLAYERS}-${TABLE_MAX_PLAYERS}人入座并准备）</div>
        `;
        bidWrap.style.display = "none";
        playActions.style.display = "none";
      }
    }

    function renderHand() {
      const cards = sortedHandCards(state.hand);
      if (!cards.length) {
        handCards.innerHTML = '<span class="small muted">暂无手牌</span>';
        return;
      }

      const canPlay = state.room?.status === "playing"
        && state.room?.game?.bottomClaimed
        && getMySeat(state.room) === state.room?.game?.turnSeat;

      handCards.innerHTML = cards.map((c) => {
        const red = c.red ? "red" : "";
        return `<button class="card-btn ${red}" data-card="${escapeHtml(c.id)}" ${canPlay ? "" : "disabled"}>${escapeHtml(c.label)}</button>`;
      }).join("");

      handCards.querySelectorAll("button[data-card]").forEach((btn) => {
        btn.addEventListener("click", async () => {
          await playCard(btn.dataset.card);
        });
      });
    }

    function renderButtons() {
      const room = state.room;
      const mySeat = getMySeat(room);
      const isReady = room?.ready?.[state.uid];
      const isHost = room?.hostUid === state.uid;

      toggleReadyBtn.disabled = !(room && room.status === "lobby" && mySeat !== null);
      toggleReadyBtn.textContent = isReady ? "取消准备" : "准备";

      const activeSeats = room ? activeSeatsFrom(room.seats, room.seatCount) : [];
      const seatOk = activeSeats.length >= TABLE_MIN_PLAYERS && activeSeats.length <= TABLE_MAX_PLAYERS;
      const readyOk = seatOk && activeSeats.every((seat) => room.ready?.[room.seats[String(seat)]]);
      startBtn.disabled = !(room && isHost && room.status === "lobby" && readyOk);
      hostTakeoverBtn.disabled = !(room && room.members && !room.members[room.hostUid] && room.members[state.uid]);
      passBtn.disabled = !(room && room.status === "playing" && mySeat === room.game?.turnSeat && room.game?.lastPlay && room.game?.trickLeaderSeat !== mySeat);
    }

    function render() {
      renderRoomInfo();
      renderSeats();
      renderGame();
      renderHand();
      renderButtons();
    }

    async function initAuth() {
      if (!supabase) {
        authStatus.textContent = "未配置 Supabase";
        showMsg("请先在 index.html 填写 SUPABASE_CONFIG（url + publishableKey）", true);
        return;
      }

      authStatus.textContent = "匿名登录中...";

      const { data: listener } = supabase.auth.onAuthStateChange((_event, session) => {
        if (session?.user) {
          state.uid = session.user.id;
          authStatus.textContent = `匿名登录：${state.uid.slice(0, 8)}...`;
          render();
        }
      });

      state.authUnsub = () => listener.subscription.unsubscribe();

      const { data: sessData, error: sessErr } = await supabase.auth.getSession();
      if (sessErr) {
        authStatus.textContent = `获取会话失败：${friendlyErr(sessErr)}`;
        showMsg(`登录失败：${friendlyErr(sessErr)}`, true);
        return;
      }

      if (!sessData.session) {
        const { data, error } = await supabase.auth.signInAnonymously();
        if (error) {
          authStatus.textContent = `匿名登录失败：${friendlyErr(error)}`;
          showMsg(`匿名登录失败：${friendlyErr(error)}`, true);
          return;
        }
        state.uid = data.user?.id || "";
      } else {
        state.uid = sessData.session.user.id;
      }

      authStatus.textContent = `匿名登录：${state.uid.slice(0, 8)}...`;
      const roomFromUrl = new URL(location.href).searchParams.get("room");
      if (roomFromUrl && !state.roomId) {
        await joinRoom(roomFromUrl);
      }
    }

    saveNickBtn.addEventListener("click", async () => {
      const nextNick = nicknameInput.value.trim().slice(0, 12);
      if (!nextNick) return;
      state.nick = nextNick;
      localStorage.setItem("ddz_nick", nextNick);

      if (state.roomId && state.uid) {
        await mutateRoom(state.roomId, (room) => {
          ensureRoomStateShape(room);
          if (!room.state.members[state.uid]) return false;
          room.state.members[state.uid].nick = nextNick;
        });
      }
      log(`昵称已更新为 ${nextNick}`);
    });

    createRoomBtn.addEventListener("click", async () => {
      await createRoom();
    });

    joinRoomBtn.addEventListener("click", async () => {
      await joinRoom(roomCodeInput.value);
    });

    leaveRoomBtn.addEventListener("click", async () => {
      await leaveRoom();
    });

    copyLinkBtn.addEventListener("click", async () => {
      if (!state.roomId) return;
      const link = `${location.origin}${location.pathname}?room=${state.roomId}`;
      await navigator.clipboard.writeText(link);
      showMsg("邀请链接已复制");
    });

    toggleReadyBtn.addEventListener("click", async () => {
      await toggleReady();
    });

    startBtn.addEventListener("click", async () => {
      await startGame();
    });

    hostTakeoverBtn.addEventListener("click", async () => {
      await takeHost();
    });

    bidWrap.querySelectorAll("button[data-bid]").forEach((btn) => {
      btn.addEventListener("click", async () => {
        await bid(Number(btn.dataset.bid));
      });
    });

    passBtn.addEventListener("click", async () => {
      await pass();
    });

    window.addEventListener("beforeunload", () => {
      if (state.pollTimer) clearInterval(state.pollTimer);
      for (const fn of state.roomUnsubs) fn();
      if (state.authUnsub) state.authUnsub();
    });

    window.__ddzState = state;
    render();
    initAuth();
  </script>
</body>
</html>
