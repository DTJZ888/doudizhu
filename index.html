<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>不忘初心、牢记使命，必须发扬斗争精神</title>
  <style>
    :root {
      --bg: #f1ecdf;
      --card: rgba(255, 253, 247, 0.88);
      --ink: #211d17;
      --accent: #0e6c43;
      --warn: #96421a;
      --line: #d4cab6;
      --gold: #d6ab42;
      --surface: #f8f3e9;
      --shadow: 0 10px 28px rgba(45, 36, 22, 0.13);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Noto Sans SC", "PingFang SC", "Microsoft YaHei", sans-serif;
      background:
        radial-gradient(circle at 8% -2%, #fff6da 0, transparent 34%),
        radial-gradient(circle at 94% 5%, #fcead7 0, transparent 28%),
        linear-gradient(160deg, #f6f2e8 0%, #efe7d8 100%);
      color: var(--ink);
    }
    body.locked {
      overflow: hidden;
    }
    .gate-overlay {
      position: fixed;
      inset: 0;
      z-index: 1000;
      display: none;
      align-items: center;
      justify-content: center;
      background:
        radial-gradient(circle at 20% 15%, rgba(255, 247, 220, .72) 0, transparent 42%),
        linear-gradient(165deg, rgba(43, 37, 29, .76), rgba(25, 21, 16, .92));
      backdrop-filter: blur(4px);
    }
    .gate-card {
      width: min(92vw, 420px);
      background: #fffdf6;
      border: 1px solid #d7c9aa;
      border-radius: 14px;
      box-shadow: 0 16px 36px rgba(15, 10, 6, .4);
      padding: 16px;
      display: grid;
      gap: 10px;
    }
    .gate-title {
      margin: 0;
      font-size: 18px;
    }
    .gate-msg {
      font-size: 12px;
      color: #8f2b1f;
      min-height: 18px;
    }
    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: 16px;
      display: grid;
      gap: 12px;
    }
    .panel {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(5px);
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
    }
    h1 { margin: 0; font-size: 20px; }
    h2 { margin: 0 0 8px; font-size: 16px; }
    input, button, select {
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 14px;
      background: #fff;
      color: var(--ink);
    }
    button {
      cursor: pointer;
      background: #f7f3ea;
      transition: transform .15s ease, box-shadow .15s ease, background .15s ease;
    }
    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 5px 14px rgba(38, 30, 18, .16);
      background: #fff9ee;
    }
    button.primary { border-color: #115f3b; background: var(--accent); color: #fff; }
    button.warn { border-color: #82370f; background: var(--warn); color: #fff; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 12px;
    }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .small { font-size: 12px; color: #5b554c; }
    .muted { color: #6f675d; }
    .layout-tools { margin-top: 8px; }
    .layout-tools button {
      padding: 5px 9px;
      font-size: 12px;
      border-radius: 999px;
      border-color: #d6c6a8;
      background: #fff8e9;
    }
    .layout-tools button.active {
      border-color: #2d7a53;
      background: #e6f7ee;
      color: #174730;
      box-shadow: 0 4px 10px rgba(20, 88, 58, .18);
    }
    #globalLayoutTools {
      margin-top: 8px;
      justify-content: flex-end;
    }
    #toggleCoreUiFloatBtn {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 950;
      display: none;
      border-radius: 999px;
      border-color: #cfbf9d;
      background: rgba(255, 249, 237, .96);
      box-shadow: 0 6px 14px rgba(39, 29, 16, .2);
      padding: 6px 10px;
      font-size: 12px;
    }
    .seats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap: 8px;
    }
    .seat {
      border: 1px dashed #ccbfa8;
      border-radius: 12px;
      padding: 10px;
      min-height: 108px;
      background: linear-gradient(180deg, #fffdfa 0%, #faf5ec 100%);
    }
    .seat.you {
      border-color: #1a7a4c;
      background: linear-gradient(180deg, #eefbf3 0%, #e4f3ea 100%);
    }
    .seat-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
    }
    .seat-meta {
      margin-top: 6px;
      font-size: 12px;
      color: #5a4f40;
    }
    .seat-actions {
      margin-top: 8px;
    }
    .seats.table-view {
      position: relative;
      display: block;
      min-height: 340px;
      border: 1px solid #3f5f95;
      border-radius: 14px;
      background: linear-gradient(180deg, #496ba2 0%, #3e5f95 100%);
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .12);
    }
    .seats.table-view .seat {
      position: absolute;
      min-height: 0;
      width: 170px;
      padding: 8px;
      border: 1px solid rgba(228, 218, 191, .7);
      background: rgba(253, 249, 240, .94);
      box-shadow: 0 6px 14px rgba(24, 28, 40, .22);
      z-index: 2;
    }
    .seats.table-view .seat[data-slot="top"] {
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      width: min(46%, 460px);
    }
    .seats.table-view .seat[data-slot="left"] {
      left: 8px;
      top: 32%;
      transform: translateY(-50%);
      width: min(28%, 210px);
    }
    .seats.table-view .seat[data-slot="right"] {
      right: 8px;
      top: 32%;
      transform: translateY(-50%);
      width: min(28%, 210px);
    }
    .seats.table-view .seat[data-slot="bottom"] {
      left: 50%;
      bottom: 8px;
      transform: translateX(-50%);
      width: min(92%, 920px);
      min-height: 188px;
    }
    .table-info-hud {
      position: absolute;
      left: 10px;
      top: 10px;
      width: min(40%, 420px);
      padding: 7px 9px;
      border-radius: 10px;
      border: 1px solid rgba(232, 220, 190, .5);
      background: rgba(238, 231, 213, .28);
      backdrop-filter: blur(2px);
      text-align: left;
      color: #f8f4e9;
      text-shadow: 0 1px 2px rgba(25, 34, 56, .7);
      font-size: 12px;
      z-index: 3;
    }
    .table-info-hud .line {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .table-last-play {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      min-width: 200px;
      max-width: 78%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(224, 206, 172, .85);
      background: rgba(255, 249, 237, .92);
      box-shadow: 0 6px 16px rgba(52, 42, 26, .18);
      z-index: 4;
    }
    .table-last-play-cards {
      display: flex;
      gap: 6px;
      align-items: center;
      overflow-x: auto;
      max-width: 100%;
    }
    .table-last-play .played-card {
      width: 40px;
      height: 58px;
      border-radius: 7px;
    }
    .seat-hand-mini {
      margin-top: 6px;
      display: flex;
      align-items: flex-end;
      overflow-x: auto;
      padding-bottom: 2px;
    }
    .seat-hand-mini-card {
      width: 26px;
      height: 38px;
      border-radius: 5px;
      border: 1px solid rgba(223, 206, 171, .9);
      box-shadow: 0 2px 5px rgba(38, 30, 18, .22);
      margin-left: -10px;
      background: #fff;
      flex: 0 0 auto;
    }
    .seat-hand-mini-card:first-child {
      margin-left: 0;
    }
    .table-center-dock {
      position: absolute;
      left: 16%;
      right: 16%;
      top: 34%;
      bottom: 228px;
      z-index: 3;
      display: flex;
    }
    .table-center-dock > #playedPanel {
      width: 100%;
      border: 0;
      border-radius: 10px;
      padding: 0;
      box-shadow: none;
      background: transparent;
      min-height: 0;
      display: flex;
    }
    .table-center-dock > #playedPanel h2 {
      display: none;
    }
    .table-center-dock > #playedPanel .played-zone {
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(224, 206, 172, .9);
      background: rgba(255, 249, 237, .95);
      box-shadow: 0 6px 16px rgba(52, 42, 26, .18);
      width: 100%;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .table-center-dock > #playedPanel #playedNow {
      min-height: 0;
      max-height: none;
      flex: 1 1 auto;
    }
    .seat-play-dock {
      margin-top: 8px;
    }
    .seat-play-dock > #gamePanel {
      width: 100%;
      border: 0;
      border-radius: 10px;
      padding: 6px 8px;
      box-shadow: none;
      background: rgba(255, 249, 237, .95);
    }
    .seat-play-dock > #gamePanel h2 {
      display: none;
    }
    .seat-play-dock > #gamePanel #gameInfo {
      margin-bottom: 6px;
    }
    .hidden-hand {
      margin-top: 6px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .hidden-hand-stack {
      position: relative;
      width: 52px;
      height: 34px;
      flex: 0 0 auto;
    }
    .hidden-hand-card {
      position: absolute;
      top: 0;
      left: calc(var(--idx) * 7px);
      width: 24px;
      height: 34px;
      border-radius: 5px;
      border: 1px solid #d9d6c8;
      background:
        linear-gradient(135deg, #f7f6ef 0 25%, #cdc8b6 25% 50%, #f7f6ef 50% 75%, #cdc8b6 75% 100%);
      background-size: 12px 12px;
      box-shadow: 0 2px 6px rgba(35, 33, 25, .22);
    }
    .hidden-hand-count {
      display: inline-block;
      min-width: 42px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #dbcba8;
      background: #fff7e7;
      font-size: 12px;
      color: #5a4c37;
      text-align: center;
    }
    .pill {
      display: inline-block;
      border: 1px solid #cdbf9f;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 12px;
      margin-right: 6px;
      background: #fff9ec;
    }
    #handCards {
      display: flex;
      flex-wrap: nowrap;
      min-height: 112px;
      align-items: flex-end;
      padding: 8px 8px 10px;
      overflow-x: auto;
      overflow-y: visible;
      touch-action: manipulation;
      user-select: none;
    }
    .hand-scroll-wrap {
      margin-top: 6px;
      padding: 0 6px 2px;
      display: none;
    }
    #handScrollBar {
      width: 100%;
      accent-color: #2b7d53;
      cursor: pointer;
    }
    .card-btn {
      border: 0;
      border-radius: 12px;
      background: transparent;
      min-width: auto;
      padding: 0;
      box-shadow: none;
      margin-left: -38px;
      position: relative;
      z-index: 1;
      flex: 0 0 auto;
    }
    #handCards .card-btn:first-child { margin-left: 0; }
    .card-img {
      width: 72px;
      height: 104px;
      display: block;
      border-radius: 12px;
      box-shadow: 0 6px 14px rgba(44, 33, 18, .2);
      transition: transform .16s ease, box-shadow .16s ease, filter .16s ease;
    }
    .card-btn:hover:not(:disabled) .card-img {
      transform: translateY(-6px);
      box-shadow: 0 12px 20px rgba(42, 33, 19, .24);
      filter: saturate(1.08);
    }
    .card-btn:hover:not(:disabled) { z-index: 20; }
    .card-btn:disabled .card-img {
      filter: grayscale(.22) saturate(.74) brightness(.93);
      opacity: .8;
      box-shadow: 0 4px 9px rgba(44, 33, 18, .14);
    }
    .card-btn.selected .card-img {
      transform: translateY(-8px);
      box-shadow: 0 13px 20px rgba(42, 33, 19, .24);
    }
    .card-btn.selected { z-index: 30; }
    .red { color: #b61f1f; }
    .log {
      max-height: 180px;
      overflow: auto;
      margin: 0;
      padding-left: 18px;
    }
    .log li { margin-bottom: 4px; }
    .played-zone {
      display: grid;
      gap: 10px;
    }
    .played-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .played-row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      min-height: 70px;
      padding: 8px;
      border: 1px solid #dbcdb5;
      border-radius: 10px;
      background: linear-gradient(180deg, #fffdf8 0%, #f8f1e3 100%);
      overflow: auto;
      scroll-behavior: smooth;
    }
    .rules-box {
      border: 1px solid #decfb5;
      border-radius: 10px;
      background: linear-gradient(180deg, #fffdf8 0%, #f8f1e3 100%);
      padding: 10px;
      line-height: 1.55;
      font-size: 13px;
      color: #4f4436;
      white-space: pre-wrap;
    }
    .played-chip {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      min-width: 68px;
    }
    .played-turn {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-right: 8px;
      padding-right: 8px;
      border-right: 1px dashed #d8c8ae;
      flex: 0 0 auto;
      transform-origin: center bottom;
    }
    .played-turn.played-new {
      animation: played-turn-enter .34s cubic-bezier(.22, .83, .21, 1.15);
    }
    @keyframes played-turn-enter {
      from { transform: translateY(10px) scale(.94); opacity: .45; }
      to { transform: translateY(0) scale(1); opacity: 1; }
    }
    .played-turn-cards {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .played-card {
      width: 54px;
      height: 78px;
      border-radius: 9px;
      box-shadow: 0 4px 10px rgba(45, 34, 19, .2);
      display: block;
    }
    .played-cap {
      font-size: 11px;
      color: #5f5547;
      max-width: 78px;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      text-align: center;
    }
    .played-call-row {
      flex: 1 0 100%;
      display: flex;
      align-items: center;
      gap: 10px;
      padding-bottom: 6px;
      margin-bottom: 2px;
      border-bottom: 1px dashed #d8c8ae;
    }
    .played-owner-chip {
      display: flex;
      flex-direction: column;
      gap: 3px;
      justify-content: center;
      min-width: 92px;
      padding: 6px 8px;
      border: 1px solid #dcc9aa;
      border-radius: 8px;
      background: linear-gradient(180deg, #fff8eb 0%, #f6ebd7 100%);
    }
    .played-owner-name {
      font-size: 12px;
      color: #4b3e2b;
      font-weight: 600;
      max-width: 140px;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }
    .played-card-call {
      width: 40px;
      height: 58px;
      border-radius: 7px;
    }
    .played-cap-call {
      font-size: 10px;
      max-width: 120px;
    }
    #teamCallOptions .card-btn {
      margin-left: 0;
      border: 0;
      background: transparent;
      padding: 0;
    }
    .msg-board {
      display: grid;
      gap: 8px;
    }
    .msg-list {
      margin: 0;
      padding-left: 18px;
      max-height: 220px;
      overflow: auto;
    }
    .msg-list li {
      margin-bottom: 6px;
      line-height: 1.45;
    }
    .msg-meta {
      color: #6a6358;
      font-size: 12px;
      margin-right: 6px;
    }
    .ok { color: #126842; }
    .err { color: #9e3316; }
    .hero-note {
      margin-top: 6px;
      padding: 8px 10px;
      border-radius: 10px;
      background: linear-gradient(90deg, #fff7e4 0%, #f8efd9 100%);
      border: 1px solid #e2d2b3;
      color: #6a5731;
      font-size: 12px;
    }
    .turn-banner {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 10px;
      border-radius: 999px;
      border: 1px solid #deb667;
      background: linear-gradient(180deg, #fff2cf 0%, #f8df9f 100%);
      color: #6e4f1a;
      font-weight: 700;
      animation: turn-banner-glow 1.2s ease-in-out infinite;
    }
    @keyframes turn-banner-glow {
      0%, 100% { box-shadow: 0 0 0 rgba(216, 161, 42, 0); }
      50% { box-shadow: 0 0 14px rgba(216, 161, 42, .34); }
    }
    .seat.turning {
      border-color: #d0972f;
      box-shadow:
        0 0 0 2px rgba(213, 158, 46, .26) inset,
        0 0 18px rgba(215, 153, 35, .34);
      animation: seat-turn-pulse 1.2s ease-in-out infinite;
    }
    @keyframes seat-turn-pulse {
      0%, 100% {
        box-shadow:
          0 0 0 2px rgba(213, 158, 46, .24) inset,
          0 0 14px rgba(215, 153, 35, .28);
      }
      50% {
        box-shadow:
          0 0 0 2px rgba(213, 158, 46, .35) inset,
          0 0 22px rgba(225, 165, 44, .48);
      }
    }
    .victory-overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1200;
      background: rgba(32, 17, 0, .35);
      backdrop-filter: blur(1px);
    }
    .victory-overlay.show { display: flex; }
    .victory-confetti,
    .victory-fireworks {
      position: absolute;
      inset: 0;
      overflow: hidden;
      pointer-events: none;
    }
    .confetti-piece {
      position: absolute;
      top: -12vh;
      width: 8px;
      height: 18px;
      border-radius: 2px;
      opacity: .96;
      animation: confetti-fall linear forwards;
    }
    @keyframes confetti-fall {
      from { transform: translate3d(0, -12vh, 0) rotate(0deg); }
      to { transform: translate3d(var(--drift, 0px), 112vh, 0) rotate(560deg); }
    }
    .firework-burst {
      position: absolute;
      width: 0;
      height: 0;
      left: 0;
      top: 0;
      pointer-events: none;
    }
    .firework-spark {
      position: absolute;
      width: 4px;
      height: 4px;
      border-radius: 999px;
      background: hsl(var(--h), 92%, 60%);
      box-shadow: 0 0 6px rgba(255, 219, 132, .9);
      animation: spark-burst 880ms ease-out forwards;
    }
    @keyframes spark-burst {
      from { transform: translate3d(0, 0, 0) scale(1); opacity: 1; }
      to { transform: translate3d(var(--dx, 0px), var(--dy, 0px), 0) scale(.25); opacity: 0; }
    }
    .firework-ring {
      position: absolute;
      width: 10px;
      height: 10px;
      margin-left: -5px;
      margin-top: -5px;
      border-radius: 999px;
      border: 2px solid rgba(255, 215, 140, .9);
      animation: ring-pop 680ms ease-out forwards;
      pointer-events: none;
    }
    @keyframes ring-pop {
      from { transform: scale(.2); opacity: 1; }
      to { transform: scale(6.8); opacity: 0; }
    }
    .victory-card {
      position: relative;
      z-index: 2;
      width: min(92vw, 420px);
      padding: 18px 18px 16px;
      border-radius: 16px;
      border: 1px solid #f2d8a5;
      background: linear-gradient(180deg, #fff8e8 0%, #f9ecd0 100%);
      box-shadow: 0 20px 50px rgba(30, 16, 0, .35);
      text-align: center;
      color: #4f3f26;
    }
    .victory-title {
      font-size: 28px;
      font-weight: 800;
      letter-spacing: .04em;
      color: #b22d18;
      margin-bottom: 8px;
    }
    #victoryText {
      color: #5f4f35;
      margin-bottom: 12px;
      line-height: 1.5;
    }
    #victoryCloseBtn {
      background: #8f2e1c;
      color: #fff;
      border-color: #7a2413;
    }
    body.in-match .grid {
      grid-template-columns: minmax(300px, .95fr) minmax(430px, 1.25fr);
      grid-template-areas:
        "game played"
        "room rules";
      align-items: start;
    }
    body.in-match #roomSeatPanel { grid-area: room; }
    body.in-match #gamePanel { grid-area: game; }
    body.in-match #playedPanel { grid-area: played; }
    body.in-match #rulesPanel { grid-area: rules; }
    body.in-match #gamePanel,
    body.in-match #playedPanel {
      border-color: #cfae7a;
      box-shadow: 0 14px 26px rgba(70, 51, 22, .18);
    }
    body.in-match #gameInfo {
      font-size: 13px;
      display: grid;
      gap: 6px;
      margin-bottom: 4px;
      padding: 10px;
      border: 1px solid #decbab;
      border-radius: 10px;
      background: linear-gradient(180deg, #fffdf8 0%, #f8f0dd 100%);
    }
    body.in-match #playedNow {
      min-height: 170px;
      max-height: 330px;
    }
    body.in-match .played-head .small {
      font-size: 13px;
      color: #514635;
      font-weight: 600;
    }
    body.landscape-ui .wrap { max-width: 1440px; }
    body.landscape-ui .grid {
      grid-template-columns: minmax(340px, .95fr) minmax(430px, 1.25fr);
      align-items: start;
    }
    body.landscape-ui .panel { padding: 12px; }
    body.landscape-ui #handCards { min-height: 96px; }
    body.landscape-ui .card-img { width: 64px; height: 92px; }
    body.landscape-ui #handCards .card-btn { margin-left: -26px; }
    body.landscape-ui #handCards .card-btn:first-child { margin-left: 0; }
    body.landscape-ui.in-match .grid {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 0;
      padding: 8px;
      border: 1px solid #ccb78f;
      border-radius: 16px;
      background: linear-gradient(180deg, rgba(255, 251, 243, .97) 0%, rgba(248, 239, 223, .95) 100%);
      box-shadow: 0 16px 30px rgba(63, 44, 18, .18);
    }
    body.landscape-ui.in-match.table-core-ui #headerPanel,
    body.landscape-ui.in-match.table-core-ui #lobbyPanel,
    body.landscape-ui.in-match.table-core-ui #rulesPanel,
    body.landscape-ui.in-match.table-core-ui #eventPanel,
    body.landscape-ui.in-match.table-core-ui #messagePanel {
      display: none;
    }
    body.landscape-ui.in-match #roomSeatPanel,
    body.landscape-ui.in-match #playedPanel,
    body.landscape-ui.in-match #gamePanel {
      width: 100%;
      border: 0;
      border-radius: 0;
      background: transparent;
      box-shadow: none;
      padding: 10px 8px;
    }
    body.landscape-ui.in-match #roomSeatPanel {
      order: 1;
      border-bottom: 1px solid rgba(183, 156, 106, .36);
      min-height: 260px;
    }
    body.landscape-ui.in-match #playedPanel {
      order: 2;
      border-bottom: 1px solid rgba(183, 156, 106, .32);
      min-height: 170px;
      max-height: 240px;
    }
    body.landscape-ui.in-match #gamePanel {
      order: 3;
      min-height: 230px;
      display: flex;
      flex-direction: column;
    }
    body.landscape-ui.in-match #rulesPanel {
      order: 4;
    }
    body.landscape-ui.in-match.table-core-ui #roomSeatPanel h2,
    body.landscape-ui.in-match.table-core-ui #roomInfo,
    body.landscape-ui.in-match.table-core-ui #roomActions {
      display: none;
    }
    body.landscape-ui.in-match #playedPanel h2,
    body.landscape-ui.in-match #gamePanel h2 {
      margin: 0 0 6px;
      font-size: 13px;
      color: #4f4435;
    }
    body.landscape-ui.in-match #playedNow {
      min-height: 100px;
      max-height: 165px;
    }
    body.landscape-ui.in-match #gameInfo {
      margin-bottom: 6px;
    }
    body.landscape-ui.in-match #handSection {
      margin-top: auto !important;
    }
    body.landscape-ui.in-match .seats.table-view {
      width: 100%;
    }
    #unifiedWindowHost {
      display: none;
    }
    body.landscape-ui.in-match.table-core-ui #toggleCoreUiFloatBtn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    body.landscape-ui.in-match.table-core-ui .grid {
      padding: 8px;
      min-height: auto;
      background: linear-gradient(180deg, rgba(255, 250, 241, .98) 0%, rgba(247, 237, 220, .96) 100%);
    }
    body.landscape-ui.in-match.table-core-ui #roomSeatPanel {
      min-height: auto;
      border-bottom: 0;
      padding: 6px;
      z-index: 1;
    }
    body.landscape-ui.in-match.table-core-ui #unifiedWindowHost {
      display: none;
    }
    body.landscape-ui.in-match.table-core-ui .seats.table-view {
      min-height: 62dvh;
      border-color: #3c5f95;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .14), 0 8px 18px rgba(35, 31, 24, .22);
    }
    body.landscape-ui.in-match.table-core-ui .table-center-dock {
      left: 14%;
      right: 14%;
      top: 35%;
      bottom: 236px;
    }
    body.landscape-ui.in-match.table-core-ui .table-last-play {
      display: none;
    }
    body.landscape-ui.in-match.table-core-ui .seat-hand-mini {
      display: none;
    }
    @media (max-width: 980px) {
      body.landscape-ui .grid { grid-template-columns: 1fr; }
      body.in-match .grid {
        grid-template-columns: 1fr;
        grid-template-areas:
          "game"
          "played"
          "room"
          "rules";
      }
      #globalLayoutTools { justify-content: flex-start; }
    }
    @media (max-width: 680px) {
      h1 { font-size: 17px; }
      .wrap { padding: 12px; }
      .panel { padding: 12px; }
      .card-img { width: 62px; height: 90px; }
      .card-btn { margin-left: -30px; }
      .played-card { width: 46px; height: 66px; }
      .played-card-call { width: 34px; height: 50px; }
      .played-owner-chip { min-width: 76px; padding: 5px 6px; }
      .played-owner-name { font-size: 11px; max-width: 100px; }
      .victory-title { font-size: 23px; }
    }
    @media (max-height: 560px) and (orientation: landscape) {
      body.landscape-ui .card-img { width: 56px; height: 80px; }
      body.landscape-ui #handCards .card-btn { margin-left: -20px; }
    }
    @media (hover: none) and (pointer: coarse) and (orientation: landscape) {
      body.landscape-ui.in-match .wrap {
        padding: 8px;
        gap: 8px;
      }
      body.landscape-ui.in-match .grid {
        padding: 6px;
        border-radius: 12px;
      }
      body.landscape-ui.in-match #roomSeatPanel {
        min-height: 32dvh;
        padding: 6px;
      }
      body.landscape-ui.in-match #playedPanel {
        min-height: 20dvh;
        max-height: 25dvh;
        padding: 6px;
      }
      body.landscape-ui.in-match #playedNow {
        min-height: 12dvh;
        max-height: 16dvh;
      }
      body.landscape-ui.in-match #gamePanel {
        min-height: 34dvh;
        padding: 6px;
      }
      body.landscape-ui.in-match #handCards {
        min-height: 88px;
      }
      body.landscape-ui.in-match .seats.table-view {
        min-height: 250px;
      }
      body.landscape-ui.in-match .seats.table-view .seat {
        padding: 6px;
      }
      body.landscape-ui.in-match .seats.table-view .seat[data-slot="top"] {
        width: min(48%, 420px);
      }
      body.landscape-ui.in-match .seats.table-view .seat[data-slot="left"],
      body.landscape-ui.in-match .seats.table-view .seat[data-slot="right"] {
        width: min(26%, 180px);
        top: 30%;
      }
      body.landscape-ui.in-match .seats.table-view .seat[data-slot="bottom"] {
        width: min(96%, 760px);
      }
      body.landscape-ui.in-match .table-info-hud {
        width: min(46%, 320px);
        padding: 6px 8px;
      }
      body.landscape-ui.in-match .table-center-dock {
        left: 12%;
        right: 12%;
        top: 36%;
        bottom: 214px;
      }
      body.landscape-ui.in-match .table-center-dock > #playedPanel #playedNow {
        min-height: 0;
        max-height: none;
      }
      body.landscape-ui.in-match .seat-play-dock > #gamePanel {
        padding: 6px 6px;
      }
      body.landscape-ui.in-match.table-core-ui .grid {
        min-height: auto;
      }
      body.landscape-ui.in-match.table-core-ui #roomSeatPanel {
        min-height: auto;
      }
      body.landscape-ui.in-match.table-core-ui .seats.table-view {
        min-height: 60dvh;
      }
      body.landscape-ui.in-match.table-core-ui .table-center-dock {
        left: 11%;
        right: 11%;
        top: 37%;
        bottom: 206px;
      }
      .card-img {
        transition: transform .08s ease;
        box-shadow: 0 3px 8px rgba(44, 33, 18, .18);
      }
      .card-btn:hover:not(:disabled) .card-img {
        transform: none;
        box-shadow: 0 3px 8px rgba(44, 33, 18, .18);
        filter: none;
      }
      .card-btn.selected .card-img {
        transform: translateY(-6px);
        box-shadow: 0 7px 12px rgba(42, 33, 19, .2);
      }
    }
  </style>
</head>
<body>
  <div id="gateOverlay" class="gate-overlay">
    <div class="gate-card">
      <h2 class="gate-title">访问验证</h2>
      <div class="small">请输入访问码后进入游戏。</div>
      <input id="gateInput" type="password" inputmode="numeric" placeholder="输入访问码" maxlength="12" />
      <button id="gateBtn" class="primary">进入</button>
      <div id="gateMsg" class="gate-msg"></div>
    </div>
  </div>

  <div id="victoryOverlay" class="victory-overlay" aria-hidden="true">
    <div id="victoryConfetti" class="victory-confetti"></div>
    <div id="victoryFireworks" class="victory-fireworks"></div>
    <div class="victory-card">
      <div class="victory-title">胜利！</div>
      <div id="victoryText" class="small">本局获胜</div>
      <button id="victoryCloseBtn">收起庆祝</button>
    </div>
  </div>

  <div class="wrap">
    <div class="panel" id="headerPanel">
      <div class="row" style="justify-content: space-between;">
        <h1>不忘初心、牢记使命，必须发扬斗争精神</h1>
        <div id="authStatus" class="small">登录中...</div>
      </div>
      <div class="hero-note">当前重点是联机流程验证与规则体验。</div>
      <div id="globalLayoutTools" class="layout-tools row">
        <button id="toggleLandscapeBtn" type="button">横屏布局：关</button>
        <button id="toggleCoreUiBtn" type="button">核心界面：开</button>
      </div>
    </div>

    <div class="panel" id="lobbyPanel">
      <h2>大厅</h2>
      <div class="row">
        <label>昵称</label>
        <input id="nicknameInput" maxlength="12" placeholder="输入昵称" />
        <button id="saveNickBtn">保存昵称</button>
        <label>模式</label>
        <select id="gameModeSelect">
          <option value="classic_simple">经典原型</option>
          <option value="solo_validate">单人验证</option>
          <option value="poker_a_2">双人扑克A</option>
          <option value="poker_a_4">4人扑克A</option>
          <option value="poker_b_4">4人模式B</option>
        </select>
      </div>
      <div class="row" style="margin-top: 8px;">
        <button id="createRoomBtn" class="primary">创建房间</button>
        <input id="roomCodeInput" maxlength="8" placeholder="输入房间码" class="mono" />
        <button id="joinRoomBtn">加入房间</button>
      </div>
      <div class="row" style="margin-top: 8px;">
        <span>当前房间：</span>
        <span id="roomCodeLabel" class="mono">-</span>
        <button id="copyLinkBtn">复制邀请链接</button>
        <button id="leaveRoomBtn" class="warn">离开房间</button>
      </div>
      <div id="lobbyMsg" class="small muted" style="margin-top: 8px;"></div>
    </div>

    <div class="grid">
      <div class="panel" id="roomSeatPanel">
        <h2>房间与座位</h2>
        <div id="roomInfo" class="small">尚未加入房间</div>
        <div class="seats" id="seatsWrap" style="margin-top: 8px;"></div>
        <div id="unifiedWindowHost"></div>
        <div class="row" id="roomActions" style="margin-top: 8px;">
          <button id="startBtn" class="primary">开始游戏</button>
          <button id="undoBtn">悔牌</button>
          <button id="restartBtn" class="warn">重开</button>
          <button id="closeRoomBtn" class="warn">结束房间</button>
          <button id="hostTakeoverBtn">接管房主</button>
        </div>
      </div>

      <div class="panel" id="gamePanel">
        <h2>游戏</h2>
        <div id="gameInfo" class="small">等待开局</div>
        <div class="row" id="bidWrap" style="margin-top: 8px; display: none;">
          <span>叫分：</span>
          <button data-bid="0">不叫</button>
          <button data-bid="1">1分</button>
          <button data-bid="2">2分</button>
          <button data-bid="3">3分</button>
        </div>
        <div class="row" id="playActions" style="margin-top: 8px; display: none;">
          <button id="playSelectedBtn" class="primary">出所选牌</button>
          <button id="passBtn">过牌</button>
        </div>
        <div id="teamCallWrap" style="margin-top: 8px; display: none;">
          <div id="teamCallHint" class="small"></div>
          <div id="teamCallOptions" class="row" style="margin-top: 6px;"></div>
        </div>
        <div id="handSection" style="margin-top: 8px;">
          <div class="small">你的手牌</div>
          <div class="small muted">点选每次仅变更当前这 1 张（再点可取消，不影响其他已选）；手机端横向滑动连选，已选起点可滑动取消，抬手提交。</div>
          <div id="handCards"></div>
          <div id="handScrollWrap" class="hand-scroll-wrap">
            <input id="handScrollBar" type="range" min="0" max="0" step="1" value="0" aria-label="手牌滚动条" />
          </div>
          <div class="row" style="margin-top: 6px;">
            <button id="clearSelectionBtn" type="button">取消已选</button>
            <span id="selectedCount" class="small muted">未选中</span>
          </div>
        </div>
      </div>

      <div class="panel" id="playedPanel">
        <h2>出牌窗口</h2>
        <div class="played-zone">
          <div class="played-head">
            <div id="playedTitle" class="small">上一个玩家出的牌</div>
          </div>
          <div id="playedNow" class="played-row"></div>
        </div>
      </div>

      <div class="panel" id="rulesPanel">
        <h2>规则说明</h2>
        <div id="rulesInfo" class="rules-box small"></div>
      </div>
    </div>

    <div class="panel" id="eventPanel">
      <h2>事件日志</h2>
      <ul id="eventLog" class="log small"></ul>
    </div>

    <div class="panel" id="messagePanel">
      <h2>大厅留言板</h2>
      <div class="msg-board">
        <div class="row">
          <input id="lobbyMessageInput" maxlength="200" placeholder="输入留言（最多 200 字）" style="flex: 1; min-width: 220px;" />
          <button id="sendLobbyMessageBtn" class="primary">发送留言</button>
          <button id="toggleLobbyMessagesBtn">查看全部</button>
        </div>
        <div id="lobbyMessagesHint" class="small muted">加载中...</div>
        <ul id="lobbyMessagesList" class="msg-list small"></ul>
      </div>
    </div>
  </div>
  <button id="toggleCoreUiFloatBtn" type="button">显示界面</button>

  <script type="module">
    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

    // 替换为 Supabase 项目配置。
    // 也可在页面外注入: window.SUPABASE_CONFIG = { url, publishableKey }
    const supabaseConfig = window.SUPABASE_CONFIG || {
      url: "https://eavgvsmklualdetrrznf.supabase.co",
      publishableKey: "sb_publishable_hl2JO9TOrGCldYEIitM0qA_7o6XNek_"
    };

    const TABLE_MIN_PLAYERS = 2;
    const TABLE_MAX_PLAYERS = 4;
    const TABLE_SEAT_COUNT = 4;
    const TABLE_SEAT_MIN = 1;
    const MODE_CLASSIC = "classic_simple";
    const MODE_SOLO_VALIDATE = "solo_validate";
    const MODE_POKER_A2 = "poker_a_2";
    const MODE_POKER_A4 = "poker_a_4";
    const MODE_POKER_B4 = "poker_b_4";
    const GATE_CODE = "888888";
    const MODE_B_CALLABLE_RANKS = ["4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];
    const LOBBY_MSG_PREVIEW_COUNT = 30;
    const LOBBY_MSG_PAGE_SIZE = 200;
    const AI_UID_PREFIX = "ai_";
    const LAST_ROOM_KEY_PREFIX = "ddz_last_room_";
    const SELECTED_KEY_PREFIX = "ddz_sel_";
    const PLAYED_POS_KEY_PREFIX = "ddz_played_pos_";
    const LAYOUT_LANDSCAPE_KEY = "ddz_layout_landscape";
    const TABLE_CORE_UI_KEY = "ddz_layout_table_core";
    const HOUSEKEEP_INTERVAL_MS = 15 * 60 * 1000;
    const HOUSEKEEP_EMPTY_MINUTES = 120;
    const HOUSEKEEP_FINISHED_MINUTES = 360;
    const HOUSEKEEP_KEEP_MESSAGE_DAYS = 30;

    function readStoredBool(key, fallback = false) {
      const raw = localStorage.getItem(key);
      if (raw === null) return fallback;
      return raw === "1" || raw === "true";
    }

    const state = {
      uid: "",
      nick: localStorage.getItem("ddz_nick") || `同志${Math.floor(Math.random() * 9000 + 1000)}`,
      roomId: "",
      room: null,
      hand: {},
      selectedCardIds: [],
      logs: [],
      roomUnsubs: [],
      authUnsub: null,
      pollTimer: null,
      realtimeReady: false,
      lobbyMsgs: [],
      lobbyMsgCount: 0,
      lobbyShowAll: false,
      lobbyUnsubs: [],
      lobbyPollTimer: null,
      lobbyMsgReady: false,
      lobbyMsgDisabled: false,
      aiBusy: false,
      victoryShownKey: "",
      victoryAutoTimer: null,
      victoryBurstTimers: [],
      networkOnline: typeof navigator !== "undefined" ? navigator.onLine : true,
      housekeepingTimer: null,
      lastHousekeepAt: 0,
      housekeepMissingRpc: false,
      playedScrollSaveTimer: null,
      playedRenderIds: [],
      playedRenderRoom: "",
      playedScrollRoom: "",
      touchHandledUntil: 0,
      landscapeUi: readStoredBool(LAYOUT_LANDSCAPE_KEY, false),
      tableCoreUi: readStoredBool(TABLE_CORE_UI_KEY, true)
    };

    const authStatus = document.getElementById("authStatus");
    const gateOverlay = document.getElementById("gateOverlay");
    const gateInput = document.getElementById("gateInput");
    const gateBtn = document.getElementById("gateBtn");
    const gateMsg = document.getElementById("gateMsg");
    const victoryOverlay = document.getElementById("victoryOverlay");
    const victoryConfetti = document.getElementById("victoryConfetti");
    const victoryFireworks = document.getElementById("victoryFireworks");
    const victoryText = document.getElementById("victoryText");
    const victoryCloseBtn = document.getElementById("victoryCloseBtn");
    const nicknameInput = document.getElementById("nicknameInput");
    const saveNickBtn = document.getElementById("saveNickBtn");
    const gameModeSelect = document.getElementById("gameModeSelect");
    const createRoomBtn = document.getElementById("createRoomBtn");
    const roomCodeInput = document.getElementById("roomCodeInput");
    const joinRoomBtn = document.getElementById("joinRoomBtn");
    const roomCodeLabel = document.getElementById("roomCodeLabel");
    const copyLinkBtn = document.getElementById("copyLinkBtn");
    const leaveRoomBtn = document.getElementById("leaveRoomBtn");
    const lobbyMsg = document.getElementById("lobbyMsg");
    const gridRoot = document.querySelector(".grid");
    const roomSeatPanel = document.getElementById("roomSeatPanel");
    const unifiedWindowHost = document.getElementById("unifiedWindowHost");
    const gamePanelEl = document.getElementById("gamePanel");
    const playedPanelEl = document.getElementById("playedPanel");
    const rulesPanelEl = document.getElementById("rulesPanel");
    const roomInfo = document.getElementById("roomInfo");
    const seatsWrap = document.getElementById("seatsWrap");
    const startBtn = document.getElementById("startBtn");
    const undoBtn = document.getElementById("undoBtn");
    const restartBtn = document.getElementById("restartBtn");
    const closeRoomBtn = document.getElementById("closeRoomBtn");
    const hostTakeoverBtn = document.getElementById("hostTakeoverBtn");
    const gameInfo = document.getElementById("gameInfo");
    const bidWrap = document.getElementById("bidWrap");
    const playActions = document.getElementById("playActions");
    const teamCallWrap = document.getElementById("teamCallWrap");
    const teamCallHint = document.getElementById("teamCallHint");
    const teamCallOptions = document.getElementById("teamCallOptions");
    const playSelectedBtn = document.getElementById("playSelectedBtn");
    const passBtn = document.getElementById("passBtn");
    const clearSelectionBtn = document.getElementById("clearSelectionBtn");
    const selectedCount = document.getElementById("selectedCount");
    const handCards = document.getElementById("handCards");
    const handScrollWrap = document.getElementById("handScrollWrap");
    const handScrollBar = document.getElementById("handScrollBar");
    const toggleLandscapeBtn = document.getElementById("toggleLandscapeBtn");
    const toggleCoreUiBtn = document.getElementById("toggleCoreUiBtn");
    const toggleCoreUiFloatBtn = document.getElementById("toggleCoreUiFloatBtn");
    const eventLog = document.getElementById("eventLog");
    const lobbyMessageInput = document.getElementById("lobbyMessageInput");
    const sendLobbyMessageBtn = document.getElementById("sendLobbyMessageBtn");
    const toggleLobbyMessagesBtn = document.getElementById("toggleLobbyMessagesBtn");
    const lobbyMessagesHint = document.getElementById("lobbyMessagesHint");
    const lobbyMessagesList = document.getElementById("lobbyMessagesList");
    const playedTitle = document.getElementById("playedTitle");
    const playedNow = document.getElementById("playedNow");
    const rulesInfo = document.getElementById("rulesInfo");

    nicknameInput.value = state.nick;
    gameModeSelect.value = MODE_CLASSIC;

    function log(msg) {
      const now = new Date().toLocaleTimeString();
      state.logs.unshift(`[${now}] ${msg}`);
      state.logs = state.logs.slice(0, 60);
      eventLog.innerHTML = state.logs.map((x) => `<li>${escapeHtml(x)}</li>`).join("");
    }

    function showMsg(msg, isErr = false) {
      lobbyMsg.className = `small ${isErr ? "err" : "ok"}`;
      lobbyMsg.textContent = msg;
    }

    function formatTs(ts) {
      const d = new Date(ts || Date.now());
      if (Number.isNaN(d.getTime())) return "-";
      return d.toLocaleString();
    }

    function lastRoomStorageKey(uid = state.uid) {
      return uid ? `${LAST_ROOM_KEY_PREFIX}${uid}` : "";
    }

    function selectedCardsStorageKey(roomId = state.roomId, uid = state.uid) {
      return roomId && uid ? `${SELECTED_KEY_PREFIX}${uid}_${roomId}` : "";
    }

    function playedPosStorageKey(roomId = state.roomId, uid = state.uid) {
      return roomId && uid ? `${PLAYED_POS_KEY_PREFIX}${uid}_${roomId}` : "";
    }

    function persistLastRoom(roomId) {
      const key = lastRoomStorageKey();
      if (!key) return;
      if (!roomId) {
        localStorage.removeItem(key);
        return;
      }
      localStorage.setItem(key, String(roomId));
    }

    function readLastRoom() {
      const key = lastRoomStorageKey();
      if (!key) return "";
      return localStorage.getItem(key) || "";
    }

    function persistSelectedCards() {
      const key = selectedCardsStorageKey();
      if (!key) return;
      if (!Array.isArray(state.selectedCardIds) || !state.selectedCardIds.length) {
        localStorage.removeItem(key);
        return;
      }
      localStorage.setItem(key, JSON.stringify(state.selectedCardIds.slice(0, 40)));
    }

    function restoreSelectedCards() {
      const key = selectedCardsStorageKey();
      if (!key) return [];
      const raw = localStorage.getItem(key);
      if (!raw) return [];
      try {
        const arr = JSON.parse(raw);
        return Array.isArray(arr) ? arr.map((x) => String(x || "")) : [];
      } catch {
        return [];
      }
    }

    function clearSelectedCardsPersist(roomId = state.roomId) {
      const key = selectedCardsStorageKey(roomId);
      if (key) localStorage.removeItem(key);
    }

    function savePlayedWindowPos() {
      const key = playedPosStorageKey();
      if (!key || !playedNow) return;
      const payload = {
        x: Number(playedNow.scrollLeft || 0),
        y: Number(playedNow.scrollTop || 0),
        at: Date.now()
      };
      localStorage.setItem(key, JSON.stringify(payload));
    }

    function scheduleSavePlayedWindowPos() {
      if (state.playedScrollSaveTimer) clearTimeout(state.playedScrollSaveTimer);
      state.playedScrollSaveTimer = setTimeout(() => {
        state.playedScrollSaveTimer = null;
        savePlayedWindowPos();
      }, 120);
    }

    function restorePlayedWindowPos() {
      const key = playedPosStorageKey();
      if (!key || !playedNow) return;
      const raw = localStorage.getItem(key);
      if (!raw) return;
      try {
        const pos = JSON.parse(raw);
        playedNow.scrollLeft = Number(pos?.x || 0);
        playedNow.scrollTop = Number(pos?.y || 0);
      } catch {
        // ignore malformed cache
      }
    }

    function clearPlayedPosPersist(roomId = state.roomId) {
      const key = playedPosStorageKey(roomId);
      if (key) localStorage.removeItem(key);
    }

    function setLobbyMsgDisabled(msg) {
      state.lobbyMsgDisabled = true;
      sendLobbyMessageBtn.disabled = true;
      toggleLobbyMessagesBtn.disabled = true;
      lobbyMessagesHint.textContent = msg;
    }

    function clearLobbyMsgDisabled() {
      state.lobbyMsgDisabled = false;
      sendLobbyMessageBtn.disabled = !state.uid;
      toggleLobbyMessagesBtn.disabled = false;
    }

    function renderLobbyMessages() {
      const all = state.lobbyMsgs || [];
      const shown = state.lobbyShowAll ? all : all.slice(Math.max(0, all.length - LOBBY_MSG_PREVIEW_COUNT));
      const total = state.lobbyMsgCount || all.length;

      if (!state.lobbyMsgReady) {
        lobbyMessagesHint.textContent = "留言加载中...";
      } else if (state.lobbyMsgDisabled) {
        // keep existing hint
      } else if (!all.length) {
        lobbyMessagesHint.textContent = "暂无留言，来发第一条。";
      } else if (state.lobbyShowAll) {
        lobbyMessagesHint.textContent = `共 ${total} 条留言，当前显示全部。`;
      } else {
        const hidden = Math.max(total - shown.length, 0);
        lobbyMessagesHint.textContent = hidden > 0
          ? `共 ${total} 条留言，当前显示最近 ${shown.length} 条（隐藏 ${hidden} 条）。`
          : `共 ${total} 条留言。`;
      }

      toggleLobbyMessagesBtn.textContent = state.lobbyShowAll ? "收起部分" : "查看全部";
      toggleLobbyMessagesBtn.disabled = state.lobbyMsgDisabled || !state.uid || (total <= LOBBY_MSG_PREVIEW_COUNT && !state.lobbyShowAll);
      sendLobbyMessageBtn.disabled = state.lobbyMsgDisabled || !state.uid;

      if (!shown.length) {
        lobbyMessagesList.innerHTML = '<li class="muted">暂无留言</li>';
        return;
      }

      lobbyMessagesList.innerHTML = shown.map((row) => {
        const who = escapeHtml(row.nick || row.uid?.slice(0, 8) || "匿名");
        const when = escapeHtml(formatTs(row.created_at));
        const text = escapeHtml(row.message || "").replace(/\n/g, "<br/>");
        return `<li><span class="msg-meta">[${when}] ${who}</span>${text}</li>`;
      }).join("");
    }

    async function fetchLobbyMessages(options = {}) {
      if (!supabase || !state.uid || state.lobbyMsgDisabled) return;
      const full = !!options.full;

      try {
        if (!full) {
          const { data, count, error } = await supabase
            .from("lobby_messages")
            .select("id,uid,nick,message,created_at", { count: "exact" })
            .order("created_at", { ascending: false })
            .limit(Math.max(LOBBY_MSG_PREVIEW_COUNT * 3, 90));
          if (error) throw error;

          state.lobbyMsgs = (data || []).reverse();
          if (typeof count === "number") state.lobbyMsgCount = count;
          state.lobbyMsgReady = true;
          clearLobbyMsgDisabled();
          renderLobbyMessages();
          return;
        }

        let offset = 0;
        let total = 0;
        const rows = [];
        while (true) {
          const { data, count, error } = await supabase
            .from("lobby_messages")
            .select("id,uid,nick,message,created_at", { count: offset === 0 ? "exact" : undefined })
            .order("created_at", { ascending: true })
            .range(offset, offset + LOBBY_MSG_PAGE_SIZE - 1);
          if (error) throw error;
          if (offset === 0 && typeof count === "number") total = count;
          rows.push(...(data || []));
          offset += (data || []).length;
          if (!data || data.length < LOBBY_MSG_PAGE_SIZE || (total > 0 && rows.length >= total)) break;
        }

        state.lobbyMsgs = rows;
        state.lobbyMsgCount = total || rows.length;
        state.lobbyMsgReady = true;
        clearLobbyMsgDisabled();
        renderLobbyMessages();
      } catch (err) {
        state.lobbyMsgReady = true;
        if (String(err.code || "").includes("42P01")) {
          setLobbyMsgDisabled("留言板未初始化：请在 Supabase 执行最新 supabase.schema.sql（含 lobby_messages 表）。");
        } else {
          lobbyMessagesHint.textContent = `留言加载失败：${friendlyErr(err)}`;
        }
        renderLobbyMessages();
      }
    }

    function detachLobbyListeners() {
      if (state.lobbyPollTimer) {
        clearInterval(state.lobbyPollTimer);
        state.lobbyPollTimer = null;
      }
      for (const fn of state.lobbyUnsubs) fn();
      state.lobbyUnsubs = [];
    }

    function attachLobbyListeners() {
      detachLobbyListeners();
      if (!supabase || !state.uid) return;

      state.lobbyMsgReady = false;
      state.lobbyMsgDisabled = false;
      renderLobbyMessages();
      fetchLobbyMessages({ full: state.lobbyShowAll });
      state.lobbyPollTimer = setInterval(() => {
        fetchLobbyMessages({ full: state.lobbyShowAll });
      }, 4000);

      const channel = supabase
        .channel(`lobby-messages-${Date.now()}`)
        .on(
          "postgres_changes",
          { event: "*", schema: "public", table: "lobby_messages" },
          async () => {
            await fetchLobbyMessages({ full: state.lobbyShowAll });
          }
        )
        .subscribe();

      state.lobbyUnsubs.push(() => {
        supabase.removeChannel(channel);
      });
    }

    async function sendLobbyMessage() {
      if (!supabase || !state.uid || state.lobbyMsgDisabled) return;
      const text = lobbyMessageInput.value.trim();
      if (!text) return;
      if (text.length > 200) {
        lobbyMessagesHint.textContent = "留言过长，请控制在 200 字以内。";
        return;
      }

      const { error } = await supabase
        .from("lobby_messages")
        .insert({
          uid: state.uid,
          nick: state.nick,
          message: text
        });
      if (error) {
        if (String(error.code || "").includes("42P01")) {
          setLobbyMsgDisabled("留言板未初始化：请在 Supabase 执行最新 supabase.schema.sql（含 lobby_messages 表）。");
        } else {
          lobbyMessagesHint.textContent = `发送失败：${friendlyErr(error)}`;
        }
        return;
      }

      lobbyMessageInput.value = "";
      await fetchLobbyMessages({ full: state.lobbyShowAll });
    }

    async function toggleLobbyMessages() {
      if (state.lobbyMsgDisabled || !state.uid) return;
      state.lobbyShowAll = !state.lobbyShowAll;
      await fetchLobbyMessages({ full: state.lobbyShowAll });
    }

    function escapeHtml(str) {
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function clone(obj) {
      if (typeof structuredClone === "function") return structuredClone(obj);
      return JSON.parse(JSON.stringify(obj));
    }

    function randRoomCode() {
      const chars = "ABCDEFGHJKMNPQRSTUVWXYZ23456789";
      let code = "";
      for (let i = 0; i < 6; i += 1) code += chars[Math.floor(Math.random() * chars.length)];
      return code;
    }

    function friendlyErr(err) {
      if (!err) return "未知错误";
      const code = String(err.code || "");
      const msg = String(err.message || "");
      const raw = `${code} ${msg}`;
      if (raw.includes("Anonymous") || raw.includes("anonymous")) return "匿名登录未开启（Supabase Auth -> Anonymous Sign-Ins）";
      if (raw.includes("Invalid API key") || raw.includes("JWT") || raw.includes("apikey")) return "Supabase publishable key 无效";
      if (raw.includes("NetworkError") || raw.includes("Failed to fetch")) return "网络异常，无法连接 Supabase";
      if (raw.includes("permission") || raw.includes("policy")) return "数据库权限不足（请检查 RLS 策略）";
      if (raw.includes("42P01")) return "数据表不存在（请执行最新 supabase.schema.sql）";
      if (raw.includes("42883")) return "数据库函数不存在或签名不匹配（请执行最新 supabase.schema.sql）";
      if (raw.includes("PGRST202") || raw.includes("ddz_apply_room_and_hand") || raw.includes("ddz_run_housekeeping")) {
        return "数据库未升级：请执行最新 supabase.schema.sql";
      }
      if (raw.includes("22P02")) return "数据格式错误（可能是旧房间中的 AI 标识未迁移）";
      if (raw.includes("23505")) return "房间码冲突，请重试";
      return code || msg || "未知错误";
    }

    const supabaseKey = supabaseConfig.publishableKey || supabaseConfig.anonKey || "REPLACE_ME";

    function isConfigReady() {
      return !!supabaseConfig.url
        && !!supabaseKey
        && supabaseConfig.url !== "REPLACE_ME"
        && supabaseKey !== "REPLACE_ME";
    }

    const supabase = isConfigReady()
      ? createClient(supabaseConfig.url, supabaseKey, {
        auth: { persistSession: true, autoRefreshToken: true }
      })
      : null;

    function buildSeatIndexes(seatCount = TABLE_SEAT_COUNT) {
      const n = Math.max(TABLE_SEAT_MIN, Math.min(TABLE_SEAT_COUNT, Number(seatCount) || TABLE_SEAT_COUNT));
      return Array.from({ length: n }, (_, i) => i);
    }

    function activeSeatsFrom(seats, seatCount = TABLE_SEAT_COUNT) {
      return buildSeatIndexes(seatCount).filter((seat) => !!seats?.[String(seat)]);
    }

    function getBottomCardCount(playerCount) {
      if (playerCount === 3) return 3;
      if (playerCount === 2 || playerCount === 4) return 2;
      return 2;
    }

    function modeLabel(mode) {
      if (mode === MODE_POKER_A4) return "4人扑克A";
      if (mode === MODE_POKER_B4) return "4人模式B";
      if (mode === MODE_POKER_A2) return "双人扑克A";
      if (mode === MODE_SOLO_VALIDATE) return "单人验证";
      return "经典原型";
    }

    function minPlayersForMode(mode) {
      if (mode === MODE_SOLO_VALIDATE) return 1;
      if (mode === MODE_POKER_A2) return 2;
      if (mode === MODE_POKER_A4 || mode === MODE_POKER_B4) return 4;
      return TABLE_MIN_PLAYERS;
    }

    function roomMode(roomLike) {
      return roomLike?.state?.gameMode || roomLike?.gameMode || MODE_CLASSIC;
    }

    function playedWindowLimit(roomLike) {
      const mode = roomMode(roomLike);
      if (mode === MODE_SOLO_VALIDATE) return 1;
      if (mode === MODE_POKER_A2) return 2;
      if (mode === MODE_POKER_A4 || mode === MODE_POKER_B4) return 4;
      const gameSeats = Array.isArray(roomLike?.game?.activeSeats)
        ? roomLike.game.activeSeats.filter((seat) => !!roomLike?.seats?.[String(seat)]).length
        : 0;
      const seated = gameSeats || activeSeatsFrom(roomLike?.seats, roomLike?.seatCount).length;
      return Math.max(1, seated || TABLE_MIN_PLAYERS);
    }

    function appendPlayedHistory(game, playRecord) {
      if (!game || !playRecord) return;
      if (!Array.isArray(game.trickPlays)) game.trickPlays = [];
      game.trickPlays.push(playRecord);
      if (game.trickPlays.length > 80) {
        game.trickPlays = game.trickPlays.slice(-80);
      }
    }

    function aiHexFromSeed(seed) {
      let h1 = 2166136261 >>> 0;
      let h2 = 2246822519 >>> 0;
      const text = String(seed || "");
      for (let i = 0; i < text.length; i += 1) {
        const c = text.charCodeAt(i);
        h1 ^= c;
        h1 = Math.imul(h1, 16777619) >>> 0;
        h2 ^= c;
        h2 = Math.imul(h2, 2246822519) >>> 0;
      }
      return `${h1.toString(16).padStart(8, "0")}${h2.toString(16).padStart(8, "0")}`;
    }

    function aiUuidFromSeed(seed) {
      const tail = aiHexFromSeed(seed).slice(0, 12);
      return `00000000-0000-4000-8000-${tail}`;
    }

    function legacyAiUidToUuid(uid) {
      if (typeof uid !== "string" || !uid.startsWith(AI_UID_PREFIX)) return uid;
      return aiUuidFromSeed(uid);
    }

    function isAiUid(uid, roomLike = state.room) {
      if (typeof uid !== "string") return false;
      if (uid.startsWith(AI_UID_PREFIX)) return true;
      return !!roomLike?.members?.[uid]?.isAi;
    }

    function aiUid(roomId, seat) {
      return aiUuidFromSeed(`${roomId}_${seat}`);
    }

    function hasLegacyAiIds(roomLike) {
      if (!roomLike) return false;
      const membersLegacy = Object.keys(roomLike.members || {}).some((uid) => String(uid).startsWith(AI_UID_PREFIX));
      const seatsLegacy = Object.values(roomLike.seats || {}).some((uid) => String(uid || "").startsWith(AI_UID_PREFIX));
      const callLegacy = String(roomLike.game?.teamCall?.ownerUid || "").startsWith(AI_UID_PREFIX);
      return membersLegacy || seatsLegacy || callLegacy;
    }

    function modeRulesText(mode) {
      if (mode === MODE_SOLO_VALIDATE) {
        return [
          "单人验证模式",
          "- 开局人数：1人",
          "- 发牌：54张全部发给你（无底牌）",
          "- 目标：本地快速验证出牌牌型和视觉，不需要等待他人",
          "- 出牌：选择若干牌后点击“出所选牌”"
        ].join("\n");
      }
      if (mode === MODE_POKER_A2) {
        return [
          "双人扑克A",
          "- 开局人数：2人",
          "- 先从54张中随机抽取10张，不参与本局",
          "- 剩余44张平均发给双方（各22张）",
          "- 牌型与比较规则与4人扑克A一致",
          "- 先出完手牌获胜",
          "- 若人数不足，房主点开始会自动补位AI"
        ].join("\n");
      }
      if (mode === MODE_POKER_A4) {
        return [
          "4人扑克A",
          "- 开局人数：4人",
          "- 允许牌型：单张、对子、三炸、四炸、顺子(>=3)、连对(>=3对)",
          "- 点数顺序：4<5<6<7<8<9<10<J<Q<K<A<2<3<小王<大王",
          "- 炸弹优先：双王>四炸>三炸；炸弹可压非炸弹",
          "- 捕获：44可捕获三炸，444可捕获四炸，被捕获牌并入自己手牌",
          "- 先出完手牌获胜",
          "- 若人数不足，房主点开始会自动补位AI"
        ].join("\n");
      }
      if (mode === MODE_POKER_B4) {
        return [
          "4人模式B",
          "- 开局人数：4人",
          "- 牌型与比较规则同4人扑克A",
          "- 发牌后，持有黑桃A的玩家先选择一张K及以下的具体牌（4~K）",
          "- 谁分到该牌，谁就是其队友（过程中不公开队友）",
          "- 黑桃A阵营获胜条件：该阵营两人都要在任一对手之前出完",
          "- 否则对手阵营获胜",
          "- 若人数不足，房主点开始会自动补位AI"
        ].join("\n");
      }
      return [
        "经典原型",
        "- 开局人数：2-4人",
        "- 当前只验证单张比较流程",
        "- 出牌：每次选择1张后点击“出所选牌”",
        "- 若人数不足，房主点开始会自动补位AI"
      ].join("\n");
    }

    function ensureRoomStateShape(work) {
      work.state = work.state || {};
      work.state.gameMode = work.state.gameMode || MODE_CLASSIC;
      work.state.members = work.state.members || {};
      work.state.seats = work.state.seats || {};
      work.state.ready = work.state.ready || {};
      work.state.publicCounts = work.state.publicCounts || {};

      const remap = new Map();
      for (const oldUid of Object.keys(work.state.members)) {
        if (!String(oldUid).startsWith(AI_UID_PREFIX)) continue;
        const newUid = legacyAiUidToUuid(oldUid);
        if (newUid === oldUid) continue;
        remap.set(oldUid, newUid);
        if (!work.state.members[newUid]) work.state.members[newUid] = clone(work.state.members[oldUid] || {});
        work.state.members[newUid].isAi = true;
        if (!work.state.members[newUid].nick) work.state.members[newUid].nick = "AI";
        delete work.state.members[oldUid];
      }
      if (remap.size) {
        for (const seat of Object.keys(work.state.seats)) {
          const uid = work.state.seats[seat];
          if (remap.has(uid)) work.state.seats[seat] = remap.get(uid);
        }
        for (const [oldUid, newUid] of remap.entries()) {
          if (oldUid in work.state.ready) {
            work.state.ready[newUid] = work.state.ready[oldUid];
            delete work.state.ready[oldUid];
          }
          if (oldUid in work.state.publicCounts) {
            work.state.publicCounts[newUid] = work.state.publicCounts[oldUid];
            delete work.state.publicCounts[oldUid];
          }
          if (work.state.game?.teamCall?.ownerUid === oldUid) {
            work.state.game.teamCall.ownerUid = newUid;
          }
        }
        if (remap.has(work.host_uid)) work.host_uid = remap.get(work.host_uid);
      }

      work.state.seatCount = Math.max(
        TABLE_SEAT_MIN,
        Math.min(TABLE_SEAT_COUNT, Number(work.state.seatCount) || TABLE_SEAT_COUNT)
      );
      if (work.state.gameMode === MODE_SOLO_VALIDATE) {
        work.state.seatCount = 1;
      } else if (work.state.gameMode === MODE_POKER_A2) {
        work.state.seatCount = 2;
      } else if (work.state.gameMode === MODE_POKER_B4) {
        work.state.seatCount = 4;
      } else if (work.state.gameMode === MODE_POKER_A4) {
        work.state.seatCount = 4;
      }
      work.state.seats = work.state.seats || {};
      for (const seat of buildSeatIndexes(work.state.seatCount)) {
        const key = String(seat);
        if (!(key in work.state.seats)) work.state.seats[key] = null;
      }
      if (work.state.game && !Array.isArray(work.state.game.trickPlays)) {
        work.state.game.trickPlays = [];
      }
      if (typeof work.max_members !== "number") work.max_members = 9;
    }

    function mapRoomRow(row) {
      if (!row) return null;
      const s = clone(row.state || {});
      return {
        id: row.room_id,
        hostUid: row.host_uid,
        maxMembers: row.max_members || 9,
        status: row.status,
        gameMode: s.gameMode || MODE_CLASSIC,
        seatCount: s.seatCount || TABLE_SEAT_COUNT,
        members: s.members || {},
        seats: s.seats || {},
        ready: s.ready || {},
        publicCounts: s.publicCounts || {},
        game: s.game || null,
        revision: row.revision
      };
    }

    function getMySeat(room) {
      if (!room || !room.seats || !state.uid) return null;
      for (const [seat, uid] of Object.entries(room.seats)) {
        if (uid === state.uid) return Number(seat);
      }
      return null;
    }

    function nextSeat(activeSeats, cur) {
      if (!activeSeats.length) return cur;
      const idx = activeSeats.indexOf(cur);
      if (idx === -1) return activeSeats[0];
      return activeSeats[(idx + 1) % activeSeats.length];
    }

    const SUIT_SYMBOL = { S: "♠", H: "♥", C: "♣", D: "♦" };
    const cardImageCache = new Map();

    function cardPrettyName(card) {
      if (!card) return "-";
      if (card.id === "SJ") return "小王";
      if (card.id === "BJ") return "大王";
      return `${card.rank}${SUIT_SYMBOL[card.suit] || ""}`;
    }

    function cardSvg(card) {
      const isRed = !!card.red;
      const color = isRed ? "#b51221" : "#151515";
      const border = isRed ? "#d79aa0" : "#b4b9bf";
      const rank = card.id === "SJ" || card.id === "BJ" ? "JOKER" : card.rank;
      const symbol = card.id === "SJ" || card.id === "BJ" ? "★" : (SUIT_SYMBOL[card.suit] || "");
      const center = card.id === "SJ" ? "JOKER" : card.id === "BJ" ? "JOKER+" : symbol;

      return `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 180 252">
  <defs>
    <linearGradient id="g" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0%" stop-color="#ffffff"/>
      <stop offset="100%" stop-color="#f6f0e5"/>
    </linearGradient>
  </defs>
  <rect x="6" y="6" width="168" height="240" rx="18" fill="url(#g)" stroke="${border}" stroke-width="2"/>
  <text x="20" y="34" font-size="24" font-family="Georgia, serif" font-weight="700" fill="${color}">${rank}</text>
  <text x="22" y="58" font-size="24" font-family="Georgia, serif" fill="${color}">${symbol}</text>
  <text x="90" y="142" text-anchor="middle" font-size="${card.id === "SJ" || card.id === "BJ" ? 26 : 62}" font-family="Georgia, serif" font-weight="700" fill="${color}">${center}</text>
  <g transform="translate(180,252) rotate(180)">
    <text x="20" y="34" font-size="24" font-family="Georgia, serif" font-weight="700" fill="${color}">${rank}</text>
    <text x="22" y="58" font-size="24" font-family="Georgia, serif" fill="${color}">${symbol}</text>
  </g>
</svg>`.trim();
    }

    function cardImageUrl(card) {
      if (cardImageCache.has(card.id)) return cardImageCache.get(card.id);
      const svg = cardSvg(card);
      const url = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg)}`;
      cardImageCache.set(card.id, url);
      return url;
    }

    function normalizeCard(record) {
      if (!record) return null;
      if (record.card && record.card.id) return record.card;
      const id = record.cardId || record.id;
      if (!id) return null;
      if (id === "SJ") return { id: "SJ", rank: "SJ", suit: "", power: 18, label: "小王", red: false };
      if (id === "BJ") return { id: "BJ", rank: "BJ", suit: "", power: 20, label: "大王", red: true };
      const suit = id.slice(-1);
      const rank = id.slice(0, -1);
      const rankPower = {
        "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8,
        "9": 9, "10": 10, J: 11, Q: 12, K: 13, A: 14, "2": 16
      };
      return {
        id,
        rank,
        suit,
        power: rankPower[rank] || 0,
        label: `${rank}${SUIT_SYMBOL[suit] || ""}`,
        red: suit === "H" || suit === "D"
      };
    }

    const POKER_A_ORDER = ["4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A", "2", "3", "SJ", "BJ"];
    const POKER_A_STRAIGHT_ORDER = ["4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];
    const POKER_A_VALUE = Object.fromEntries(POKER_A_ORDER.map((r, i) => [r, i + 1]));
    const POKER_A_STRAIGHT_VALUE = Object.fromEntries(POKER_A_STRAIGHT_ORDER.map((r, i) => [r, i + 1]));

    function getCardValue(card, mode) {
      if (
        mode === MODE_CLASSIC
        || mode === MODE_SOLO_VALIDATE
        || mode === MODE_POKER_A2
        || mode === MODE_POKER_B4
        || mode === MODE_POKER_A4
      ) return POKER_A_VALUE[card.rank] || 0;
      return card.power || 0;
    }

    function sortedCardsByMode(cards, mode) {
      return [...cards].sort((a, b) => {
        const d = getCardValue(a, mode) - getCardValue(b, mode);
        if (d) return d;
        return a.id.localeCompare(b.id);
      });
    }

    function isBombType(type) {
      return type === "joker_bomb" || type === "quad_bomb" || type === "triple_bomb";
    }

    function bombLevel(type) {
      if (type === "joker_bomb") return 3;
      if (type === "quad_bomb") return 2;
      if (type === "triple_bomb") return 1;
      return 0;
    }

    function analyzePokerA(cards) {
      if (!cards.length) return { ok: false, reason: "请选择要出的牌" };

      const sorted = sortedCardsByMode(cards, MODE_POKER_A4);
      const groups = {};
      for (const c of sorted) {
        groups[c.rank] = groups[c.rank] || [];
        groups[c.rank].push(c);
      }
      const ranks = Object.keys(groups).sort((a, b) => (POKER_A_VALUE[a] || 0) - (POKER_A_VALUE[b] || 0));
      const counts = ranks.map((r) => groups[r].length);
      const len = sorted.length;

      if (len === 1) {
        return { ok: true, type: "single", length: 1, mainValue: POKER_A_VALUE[ranks[0]], rankKey: ranks[0], cards: sorted };
      }

      if (len === 2) {
        if (groups.SJ && groups.BJ && ranks.length === 2) {
          return { ok: true, type: "joker_bomb", length: 2, mainValue: 999, rankKey: "JOKER", cards: sorted };
        }
        if (ranks.length === 1 && counts[0] === 2) {
          return { ok: true, type: "pair", length: 2, mainValue: POKER_A_VALUE[ranks[0]], rankKey: ranks[0], cards: sorted };
        }
      }

      if (len === 3 && ranks.length === 1 && counts[0] === 3) {
        return { ok: true, type: "triple_bomb", length: 3, mainValue: POKER_A_VALUE[ranks[0]], rankKey: ranks[0], cards: sorted };
      }

      if (len === 4 && ranks.length === 1 && counts[0] === 4) {
        return { ok: true, type: "quad_bomb", length: 4, mainValue: POKER_A_VALUE[ranks[0]], rankKey: ranks[0], cards: sorted };
      }

      if (len >= 3 && ranks.length === len && counts.every((c) => c === 1)) {
        const sv = ranks.map((r) => POKER_A_STRAIGHT_VALUE[r] || 0);
        const validRange = sv.every((v) => v > 0);
        const consecutive = validRange && sv.every((v, i) => i === 0 || v === sv[i - 1] + 1);
        if (consecutive) {
          return {
            ok: true,
            type: "straight",
            length: len,
            mainValue: sv[sv.length - 1],
            rankKey: ranks[ranks.length - 1],
            cards: sorted
          };
        }
      }

      if (len >= 6 && len % 2 === 0 && counts.every((c) => c === 2)) {
        const sv = ranks.map((r) => POKER_A_STRAIGHT_VALUE[r] || 0);
        const validRange = sv.every((v) => v > 0);
        const consecutive = validRange && sv.every((v, i) => i === 0 || v === sv[i - 1] + 1);
        if (consecutive) {
          return {
            ok: true,
            type: "seq_pair",
            length: len,
            mainValue: sv[sv.length - 1],
            rankKey: ranks[ranks.length - 1],
            cards: sorted
          };
        }
      }

      return { ok: false, reason: "不符合扑克A允许的牌型" };
    }

    function analyzeClassic(cards) {
      if (cards.length !== 1) return { ok: false, reason: "经典模式一次只能出一张牌" };
      const card = cards[0];
      return { ok: true, type: "single", length: 1, mainValue: card.power, rankKey: card.rank, cards: [card] };
    }

    function canBeatClassic(play, lastPlay, mySeat) {
      if (!lastPlay) return true;
      if (lastPlay.seat === mySeat) return true;
      return play.mainValue > (lastPlay.power || 0);
    }

    function canBeatPokerA(play, lastPlay, mySeat) {
      if (!lastPlay) return true;
      if (lastPlay.seat === mySeat) return true;

      const lastType = lastPlay.type || "single";
      const playType = play.type;
      const playBomb = isBombType(playType);
      const lastBomb = isBombType(lastType);

      if (playBomb && !lastBomb) return true;
      if (!playBomb && lastBomb) return false;

      if (playBomb && lastBomb) {
        if (playType === lastType) {
          if (playType === "joker_bomb") return false;
          return play.mainValue > (lastPlay.mainValue || 0);
        }
        return bombLevel(playType) > bombLevel(lastType);
      }

      if (playType !== lastType) return false;
      if ((playType === "straight" || playType === "seq_pair") && play.length !== lastPlay.length) return false;
      return play.mainValue > (lastPlay.mainValue || 0);
    }

    function canCaptureInPokerA(play, lastPlay, activeSeats, mySeat) {
      if (!lastPlay) return false;
      if (lastPlay.seat === mySeat) return false;
      if (!activeSeats.length) return false;
      const expectedSeat = nextSeat(activeSeats, lastPlay.seat);
      if (expectedSeat !== mySeat) return false;
      if (lastPlay.type === "triple_bomb" && play.type === "pair" && play.rankKey === "4") return true;
      if (lastPlay.type === "quad_bomb" && play.type === "triple_bomb" && play.rankKey === "4") return true;
      return false;
    }

    function makeDeck() {
      const suits = ["S", "H", "C", "D"];
      const ranks = ["3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A", "2"];
      const rankPower = {
        "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8,
        "9": 9, "10": 10, J: 11, Q: 12, K: 13, A: 14, "2": 16
      };
      const deck = [];
      for (const r of ranks) {
        for (const s of suits) {
          const id = `${r}${s}`;
          deck.push({
            id,
            rank: r,
            suit: s,
            power: rankPower[r],
            label: `${r}${SUIT_SYMBOL[s]}`,
            red: s === "H" || s === "D"
          });
        }
      }
      deck.push({ id: "SJ", rank: "SJ", suit: "", power: 18, label: "小王", red: false });
      deck.push({ id: "BJ", rank: "BJ", suit: "", power: 20, label: "大王", red: true });
      return deck;
    }

    function shuffle(arr) {
      const a = [...arr];
      const rnd = new Uint32Array(a.length);
      crypto.getRandomValues(rnd);
      for (let i = a.length - 1; i > 0; i -= 1) {
        const j = rnd[i] % (i + 1);
        const tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
      }
      return a;
    }

    function sortedHandCards(handMap) {
      const cards = Object.values(handMap || {});
      return sortedCardsByMode(cards, roomMode(state.room));
    }

    async function fetchRoomOnce() {
      if (!supabase || !state.roomId) return;
      const { data, error } = await supabase
        .from("rooms")
        .select("*")
        .eq("room_id", state.roomId)
        .maybeSingle();

      if (error) {
        showMsg(`拉取房间失败：${friendlyErr(error)}`, true);
        return;
      }

      if (!data) {
        showMsg("房间不存在或已解散", true);
        resetLocalLobbyState();
        render();
        return;
      }

      state.room = mapRoomRow(data);
      persistLastRoom(state.roomId);
      if (hasLegacyAiIds(state.room)) {
        await mutateRoom(state.roomId, (work) => {
          ensureRoomStateShape(work);
        });
        const { data: refreshed } = await supabase
          .from("rooms")
          .select("*")
          .eq("room_id", state.roomId)
          .maybeSingle();
        if (refreshed) state.room = mapRoomRow(refreshed);
      }
      await cleanupGhostSeats();
      await autoFixHost();
      await hostGrantBottomIfNeeded();
    }

    async function fetchHandOnce() {
      if (!supabase || !state.roomId || !state.uid) return;
      const { data, error } = await supabase
        .from("private_hands")
        .select("uid,cards")
        .eq("room_id", state.roomId)
        .eq("uid", state.uid)
        .maybeSingle();

      if (error && error.code !== "PGRST116") {
        showMsg(`拉取手牌失败：${friendlyErr(error)}`, true);
        return;
      }

      state.hand = data?.cards || {};
      if (!state.selectedCardIds.length) {
        state.selectedCardIds = restoreSelectedCards();
      }
      state.selectedCardIds = state.selectedCardIds.filter((id) => !!state.hand[id]);
      persistSelectedCards();
    }

    async function refreshRoomAndHand(runAi = true) {
      if (!state.roomId) return;
      await Promise.all([fetchRoomOnce(), fetchHandOnce()]);
      render();
      if (runAi) await maybeDriveAi();
    }

    function detachRoomListeners() {
      if (state.pollTimer) {
        clearInterval(state.pollTimer);
        state.pollTimer = null;
      }
      for (const fn of state.roomUnsubs) fn();
      state.roomUnsubs = [];
      state.realtimeReady = false;
    }

    function attachRoomListeners() {
      detachRoomListeners();
      if (!state.roomId || !supabase) return;

      refreshRoomAndHand();
      state.pollTimer = setInterval(refreshRoomAndHand, 1500);

      const channel = supabase
        .channel(`room-${state.roomId}-${Date.now()}`)
        .on(
          "postgres_changes",
          { event: "*", schema: "public", table: "rooms", filter: `room_id=eq.${state.roomId}` },
          async () => {
            await refreshRoomAndHand();
          }
        )
        .on(
          "postgres_changes",
          { event: "*", schema: "public", table: "private_hands", filter: `room_id=eq.${state.roomId}` },
          async (payload) => {
            const row = payload.new || payload.old;
            if (!row || row.uid !== state.uid) return;
            await fetchHandOnce();
            render();
          }
        )
        .subscribe((status) => {
          if (status === "SUBSCRIBED") {
            state.realtimeReady = true;
          }
        });

      state.roomUnsubs.push(() => {
        supabase.removeChannel(channel);
      });
    }

    async function mutateRoom(rid, mutator, retries = 8) {
      if (!supabase || !rid) return { committed: false, reason: "bad_request" };

      for (let i = 0; i < retries; i += 1) {
        const { data: row, error: selErr } = await supabase
          .from("rooms")
          .select("*")
          .eq("room_id", rid)
          .maybeSingle();

        if (selErr) throw selErr;
        if (!row) return { committed: false, reason: "not_found" };

        const work = {
          room_id: row.room_id,
          host_uid: row.host_uid,
          status: row.status,
          max_members: row.max_members,
          state: clone(row.state || {}),
          revision: row.revision
        };

        ensureRoomStateShape(work);
        const action = mutator(work);

        if (action === false) return { committed: false, reason: "rejected" };

        if (action === null) {
          const { data: deleted, error: delErr } = await supabase
            .from("rooms")
            .delete()
            .eq("room_id", rid)
            .eq("revision", row.revision)
            .select("room_id");

          if (delErr) throw delErr;
          if (deleted && deleted.length === 1) return { committed: true, deleted: true };
          continue;
        }

        const patch = {
          host_uid: work.host_uid,
          status: work.status,
          max_members: work.max_members,
          state: work.state,
          revision: row.revision + 1,
          updated_at: new Date().toISOString()
        };

        const { data: updated, error: upErr } = await supabase
          .from("rooms")
          .update(patch)
          .eq("room_id", rid)
          .eq("revision", row.revision)
          .select("room_id");

        if (upErr) throw upErr;
        if (updated && updated.length === 1) return { committed: true };
      }

      return { committed: false, reason: "conflict" };
    }

    function atomicReasonText(reason) {
      if (!reason) return "未知失败";
      if (reason === "rpc_missing") return "数据库未升级：缺少 ddz_apply_room_and_hand（请执行最新 supabase.schema.sql）";
      if (reason === "unauthenticated") return "登录状态失效，请刷新页面重试";
      if (reason === "not_found") return "房间不存在";
      if (reason === "conflict") return "并发冲突，请重试";
      if (reason === "status_not_playing") return "当前不在出牌阶段";
      if (reason === "bottom_unclaimed") return "底牌流程未完成";
      if (reason === "turn_mismatch") return "尚未轮到当前玩家";
      if (reason === "seat_actor_mismatch") return "座位与行动玩家不一致";
      if (reason === "actor_forbidden") return "无权代替该玩家行动";
      if (reason === "actor_not_ai") return "仅允许房主代替AI行动";
      if (reason === "rejected") return "校验未通过";
      return String(reason);
    }

    async function applyRoomAndHandAtomic(payload) {
      const { data, error } = await supabase.rpc("ddz_apply_room_and_hand", payload);
      if (error) {
        const code = String(error.code || "");
        const msg = String(error.message || "");
        if (code === "PGRST202" || code === "42883" || msg.includes("ddz_apply_room_and_hand")) {
          return { committed: false, reason: "rpc_missing", newRevision: null };
        }
        throw error;
      }

      const row = Array.isArray(data) ? data[0] : data;
      return {
        committed: !!row?.committed,
        reason: row?.reason || (row?.committed ? "ok" : "rejected"),
        newRevision: row?.new_revision ?? null
      };
    }

    async function mutateRoomAndHandAtomic(rid, options, mutator, retries = 8) {
      if (!supabase || !rid) return { committed: false, reason: "bad_request" };
      const cfg = options || {};

      for (let i = 0; i < retries; i += 1) {
        const { data: row, error: selErr } = await supabase
          .from("rooms")
          .select("*")
          .eq("room_id", rid)
          .maybeSingle();
        if (selErr) throw selErr;
        if (!row) return { committed: false, reason: "not_found" };

        const work = {
          room_id: row.room_id,
          host_uid: row.host_uid,
          status: row.status,
          max_members: row.max_members,
          state: clone(row.state || {}),
          revision: row.revision
        };
        ensureRoomStateShape(work);

        const action = mutator(work);
        if (action === false) return { committed: false, reason: "rejected" };

        const handUid = action && typeof action === "object" && Object.hasOwn(action, "handUid")
          ? action.handUid
          : (cfg.handUid || null);
        const handCards = action && typeof action === "object" && Object.hasOwn(action, "handCards")
          ? action.handCards
          : null;

        const out = await applyRoomAndHandAtomic({
          p_room_id: rid,
          p_expect_revision: row.revision,
          p_next_host_uid: work.host_uid,
          p_next_status: work.status,
          p_next_max_members: work.max_members,
          p_next_state: work.state,
          p_actor_uid: cfg.actorUid || null,
          p_actor_seat: Number.isInteger(cfg.actorSeat) ? cfg.actorSeat : null,
          p_require_playing: !!cfg.requirePlaying,
          p_require_bottom_claimed: !!cfg.requireBottomClaimed,
          p_hand_uid: handUid,
          p_hand_cards: handCards
        });

        if (out.committed) return { committed: true };
        if (out.reason === "conflict") continue;
        return { committed: false, reason: out.reason || "rejected" };
      }

      return { committed: false, reason: "conflict" };
    }

    async function runHousekeeping(force = false) {
      if (!supabase || !state.uid || state.housekeepMissingRpc) return;

      const now = Date.now();
      if (!force && now - state.lastHousekeepAt < HOUSEKEEP_INTERVAL_MS) return;
      state.lastHousekeepAt = now;

      const { data, error } = await supabase.rpc("ddz_run_housekeeping", {
        p_empty_minutes: HOUSEKEEP_EMPTY_MINUTES,
        p_finished_minutes: HOUSEKEEP_FINISHED_MINUTES,
        p_message_days: HOUSEKEEP_KEEP_MESSAGE_DAYS
      });

      if (error) {
        const code = String(error.code || "");
        const msg = String(error.message || "");
        if (code === "PGRST202" || code === "42883" || msg.includes("ddz_run_housekeeping")) {
          state.housekeepMissingRpc = true;
          log("提示：数据库尚未升级 housekeeping RPC（可忽略，但建议执行最新 schema）");
          return;
        }
        throw error;
      }

      const row = Array.isArray(data) ? data[0] : data;
      const archived = Number(row?.archived_finished || 0);
      const deletedEmpty = Number(row?.deleted_empty || 0);
      const deletedMessages = Number(row?.deleted_messages || 0);
      if (archived || deletedEmpty || deletedMessages) {
        log(`系统清理：归档${archived}，回收空房${deletedEmpty}，清理旧留言${deletedMessages}`);
      }
    }

    async function createRoom() {
      if (!supabase) {
        showMsg("请先填写 SUPABASE_CONFIG", true);
        return;
      }
      if (state.roomId) {
        showMsg("请先离开当前房间", true);
        return;
      }
      if (!state.uid) {
        showMsg("尚未登录，请稍后再试", true);
        return;
      }
      const selectedMode = [MODE_CLASSIC, MODE_SOLO_VALIDATE, MODE_POKER_A2, MODE_POKER_A4, MODE_POKER_B4]
        .includes(gameModeSelect.value)
        ? gameModeSelect.value
        : MODE_CLASSIC;
      const seatCount = (selectedMode === MODE_POKER_A4 || selectedMode === MODE_POKER_B4)
        ? 4
        : (selectedMode === MODE_POKER_A2 ? 2 : (selectedMode === MODE_SOLO_VALIDATE ? 1 : TABLE_SEAT_COUNT));

      try {
        for (let i = 0; i < 8; i += 1) {
          const code = randRoomCode();
          const row = {
            room_id: code,
            host_uid: state.uid,
            max_members: 9,
            status: "lobby",
            revision: 1,
            state: {
              members: {
                [state.uid]: {
                  nick: state.nick,
                  joinedAt: Date.now()
                }
              },
              gameMode: selectedMode,
              seatCount,
              seats: Object.fromEntries(buildSeatIndexes(seatCount).map((s) => [String(s), null])),
              ready: {},
              publicCounts: {},
              game: null
            }
          };

          const { data, error } = await supabase
            .from("rooms")
            .insert(row)
            .select("room_id");

          if (error) {
            if (error.code === "23505") continue;
            throw error;
          }

          if (data && data.length === 1) {
            state.roomId = code;
            persistLastRoom(code);
            roomCodeInput.value = code;
            roomCodeLabel.textContent = code;
            history.replaceState({}, "", `${location.pathname}?room=${encodeURIComponent(code)}`);
            state.playedRenderIds = [];
            state.playedRenderRoom = code;
            attachRoomListeners();
            showMsg(`已创建并加入房间 ${code}`);
            log(`已创建房间 ${code}`);
            return;
          }
        }
        showMsg("创建失败：房间码冲突，请重试", true);
      } catch (err) {
        showMsg(`创建失败：${friendlyErr(err)}`, true);
        log(`创建房间异常：${friendlyErr(err)}`);
      }
    }

    async function joinRoom(roomId, options = {}) {
      if (!supabase) {
        showMsg("请先填写 SUPABASE_CONFIG", true);
        return false;
      }
      if (state.roomId) {
        showMsg("请先离开当前房间", true);
        return false;
      }
      if (!state.uid) {
        showMsg("尚未登录，请稍后再试", true);
        return false;
      }

      const code = (roomId || "").trim().toUpperCase();
      if (!code) {
        showMsg("请输入房间码", true);
        return false;
      }

      try {
        const result = await mutateRoom(code, (room) => {
          ensureRoomStateShape(room);
          const members = room.state.members;
          const size = Object.keys(members).length;
          if (!members[state.uid] && size >= room.max_members) return false;
          members[state.uid] = {
            nick: state.nick,
            joinedAt: members[state.uid]?.joinedAt || Date.now()
          };
        });

        if (!result.committed) {
          if (!options.silent) showMsg("加入失败：房间不存在或已满（最多 9 人）", true);
          return false;
        }

        state.roomId = code;
        persistLastRoom(code);
        roomCodeInput.value = code;
        roomCodeLabel.textContent = code;
        history.replaceState({}, "", `${location.pathname}?room=${encodeURIComponent(code)}`);
        state.playedRenderIds = [];
        state.playedRenderRoom = code;
        attachRoomListeners();
        if (!options.silent) showMsg("已加入房间");
        log(`已进入房间 ${code}`);
        return true;
      } catch (err) {
        if (!options.silent) showMsg(`加入失败：${friendlyErr(err)}`, true);
        log(`加入房间异常：${friendlyErr(err)}`);
        return false;
      }
    }

    async function leaveRoom() {
      if (!supabase || !state.roomId || !state.uid) return;
      const rid = state.roomId;

      try {
        await mutateRoom(rid, (room) => {
          ensureRoomStateShape(room);
          const members = room.state.members;
          if (!members[state.uid]) return false;

          delete members[state.uid];
          delete room.state.ready[state.uid];
          delete room.state.publicCounts[state.uid];

          for (const s of buildSeatIndexes(room.state.seatCount)) {
            const key = String(s);
            if (room.state.seats[key] === state.uid) room.state.seats[key] = null;
          }

          const left = Object.keys(members);
          if (!left.length) return null;

          if (!members[room.host_uid]) {
            let nextHost = left[0];
            for (const uid of left) {
              const a = members[nextHost]?.joinedAt || Number.MAX_SAFE_INTEGER;
              const b = members[uid]?.joinedAt || Number.MAX_SAFE_INTEGER;
              if (b < a) nextHost = uid;
            }
            room.host_uid = nextHost;
          }
        });

        await supabase
          .from("private_hands")
          .delete()
          .eq("room_id", rid)
          .eq("uid", state.uid);
      } catch (err) {
        showMsg(`离开房间异常：${friendlyErr(err)}`, true);
      }

      resetLocalLobbyState();
      showMsg("已离开房间");
      render();
    }

    function resetLocalLobbyState(opts = {}) {
      const keepRoomHint = !!opts.keepRoomHint;
      const prevRoomId = state.roomId;
      detachRoomListeners();
      if (state.playedScrollSaveTimer) {
        clearTimeout(state.playedScrollSaveTimer);
        state.playedScrollSaveTimer = null;
      }
      state.roomId = "";
      state.room = null;
      state.hand = {};
      state.selectedCardIds = [];
      state.playedRenderIds = [];
      state.playedRenderRoom = "";
      state.playedScrollRoom = "";
      roomCodeLabel.textContent = "-";
      roomCodeInput.value = "";
      history.replaceState({}, "", location.pathname);
      if (!keepRoomHint) {
        persistLastRoom("");
        clearSelectedCardsPersist(prevRoomId);
        clearPlayedPosPersist(prevRoomId);
      }
    }

    async function closeRoomByHost() {
      if (!supabase || !state.roomId || !state.uid || !state.room) return;
      if (state.room.hostUid !== state.uid) {
        showMsg("仅房主可结束房间", true);
        return;
      }
      if (!window.confirm("确认结束房间？这会让所有玩家立即返回大厅。")) return;

      const rid = state.roomId;
      try {
        const tx = await mutateRoom(rid, (room) => {
          ensureRoomStateShape(room);
          if (room.host_uid !== state.uid) return false;
          return null;
        });
        if (!tx.committed) {
          showMsg("结束房间失败，请重试", true);
          return;
        }
      } catch (err) {
        showMsg(`结束房间失败：${friendlyErr(err)}`, true);
        return;
      }

      const { error: handErr } = await supabase
        .from("private_hands")
        .delete()
        .eq("room_id", rid);
      if (handErr) log(`结束房间后清理手牌失败：${friendlyErr(handErr)}`);

      resetLocalLobbyState();
      showMsg("房主已结束房间，已返回大厅");
      log(`房间 ${rid} 已结束`);
      render();
    }

    async function cleanupGhostSeats() {
      if (!state.room || !state.roomId) return;
      const room = state.room;
      const members = room.members || {};
      const seats = room.seats || {};
      let needFix = false;

      for (const s of buildSeatIndexes(room.seatCount)) {
        const uid = seats[String(s)];
        if (uid && !members[uid]) {
          needFix = true;
          break;
        }
      }
      if (!needFix) return;

      await mutateRoom(state.roomId, (work) => {
        ensureRoomStateShape(work);
        for (const s of buildSeatIndexes(work.state.seatCount)) {
          const key = String(s);
          const uid = work.state.seats[key];
          if (uid && !work.state.members[uid]) {
            work.state.seats[key] = null;
            delete work.state.ready[uid];
            delete work.state.publicCounts[uid];
          }
        }
      });
    }

    async function autoFixHost() {
      if (!state.room || !state.roomId) return;
      if (state.room.members?.[state.room.hostUid]) return;
      if (!state.room.members?.[state.uid]) return;
      await takeHost();
    }

    async function seatAction(targetSeat) {
      if (!state.roomId) return;
      await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (room.status !== "lobby") return false;
        if (!room.state.members[state.uid]) return false;

        for (const s of buildSeatIndexes(room.state.seatCount)) {
          const key = String(s);
          if (room.state.seats[key] === state.uid) room.state.seats[key] = null;
        }
        delete room.state.ready[state.uid];

        if (targetSeat !== null) {
          const key = String(targetSeat);
          const occupied = room.state.seats[key];
          if (occupied && !isAiUid(occupied, { members: room.state.members })) return false;
          if (occupied && isAiUid(occupied, { members: room.state.members })) {
            room.state.seats[key] = null;
            delete room.state.members[occupied];
            delete room.state.ready[occupied];
            delete room.state.publicCounts[occupied];
          }
          room.state.seats[key] = state.uid;
          room.state.ready[state.uid] = true;
        }
      });
    }

    async function takeHost() {
      if (!state.roomId) return;
      await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (!room.state.members[state.uid]) return false;
        if (room.state.members[room.host_uid]) return false;
        room.host_uid = state.uid;
      });
    }

    async function writeHand(uid, cards) {
      if (!supabase || !state.roomId) return;
      const { error } = await supabase
        .from("private_hands")
        .upsert({
          room_id: state.roomId,
          uid,
          cards,
          updated_at: new Date().toISOString()
        }, { onConflict: "room_id,uid" });
      if (error) throw error;
    }

    async function startGame() {
      if (!state.roomId || !state.room) return;
      if (state.room.hostUid !== state.uid || state.room.status !== "lobby") return;

      const mode = roomMode(state.room);
      let activeSeats = [];
      let seatUids = [];
      let hands = null;
      const deck = shuffle(makeDeck());
      let bottom = [];
      let openedCards = [];
      let autoAiCount = 0;

      const tx = await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (room.host_uid !== state.uid || room.status !== "lobby") return false;

        activeSeats = activeSeatsFrom(room.state.seats, room.state.seatCount);
        const minNeed = minPlayersForMode(mode);
        if (activeSeats.length < minNeed) {
          for (const seat of buildSeatIndexes(room.state.seatCount)) {
            if (activeSeats.length >= minNeed) break;
            const key = String(seat);
            if (room.state.seats[key]) continue;
            const uid = aiUid(room.room_id, seat);
            if (!room.state.members[uid]) {
              room.state.members[uid] = {
                nick: `AI-${seat + 1}`,
                joinedAt: Date.now(),
                isAi: true
              };
            }
            room.state.seats[key] = uid;
            room.state.ready[uid] = true;
            activeSeats.push(seat);
            autoAiCount += 1;
          }
        }

        if (mode === MODE_SOLO_VALIDATE) {
          if (activeSeats.length !== 1) return false;
        } else if (mode === MODE_POKER_A2) {
          if (activeSeats.length !== 2) return false;
        } else if (mode === MODE_POKER_A4 || mode === MODE_POKER_B4) {
          if (activeSeats.length !== 4) return false;
        } else if (activeSeats.length < TABLE_MIN_PLAYERS || activeSeats.length > TABLE_MAX_PLAYERS) {
          return false;
        }

        seatUids = activeSeats.map((seat) => room.state.seats[String(seat)]);

        let dealPool = deck;
        if (mode === MODE_POKER_A2) {
          openedCards = deck.slice(0, 10);
          dealPool = deck.slice(10);
          bottom = [];
        } else {
          const bottomCount = (mode === MODE_POKER_A4 || mode === MODE_POKER_B4)
            ? 2
            : (mode === MODE_SOLO_VALIDATE ? 0 : getBottomCardCount(activeSeats.length));
          const dealCount = deck.length - bottomCount;
          bottom = deck.slice(dealCount);
          dealPool = deck.slice(0, dealCount);
          if (mode === MODE_POKER_B4) {
            const idx = bottom.findIndex((c) => c.id === "AS");
            if (idx >= 0 && dealPool.length) {
              const tmp = dealPool[0];
              dealPool[0] = bottom[idx];
              bottom[idx] = tmp;
            }
          }
        }

        hands = Object.fromEntries(seatUids.map((uid) => [uid, {}]));
        room.state.publicCounts = Object.fromEntries(seatUids.map((uid) => [uid, 0]));

        for (let i = 0; i < dealPool.length; i += 1) {
          const uid = seatUids[i % seatUids.length];
          hands[uid][dealPool[i].id] = dealPool[i];
          room.state.publicCounts[uid] += 1;
        }

        const startSeat = activeSeats[Math.floor(Math.random() * activeSeats.length)] || activeSeats[0];
        const bidMap = Object.fromEntries(activeSeats.map((seat) => [String(seat), null]));

        let teamCall = null;
        if (mode === MODE_POKER_B4) {
          const ownerSeat = activeSeats.find((seat, idx) => {
            const uid = seatUids[idx];
            return !!hands[uid]?.AS;
          });
          if (ownerSeat === undefined) return false;

          const ownerUid = room.state.seats[String(ownerSeat)];
          const options = [];
          const seatByCard = {};

          for (let i = 0; i < activeSeats.length; i += 1) {
            const seat = activeSeats[i];
            const uid = seatUids[i];
            const cards = Object.values(hands[uid] || {});
            for (const card of cards) {
              if (!MODE_B_CALLABLE_RANKS.includes(card.rank)) continue;
              if (seat === ownerSeat) continue;
              options.push(card);
              seatByCard[card.id] = seat;
            }
          }

          teamCall = {
            ownerSeat,
            ownerUid,
            resolved: false,
            chosenCardId: null,
            chosenLabel: null,
            teammateSeat: null,
            options: sortedCardsByMode(options, MODE_POKER_A4).map((c) => c.id),
            seatByCard
          };
        }

        const round = ((room.state.game && room.state.game.round) || 0) + 1;
        room.status = mode === MODE_CLASSIC ? "bidding" : "playing";
        room.state.game = {
          mode,
          round,
          activeSeats,
          bid: mode === MODE_CLASSIC ? {
            currentSeat: startSeat,
            acted: 0,
            bids: bidMap,
            highestBid: 0,
            highestSeat: null
          } : null,
          landlordSeat: null,
          bottomCards: bottom,
          openedCards,
          bottomClaimed: mode !== MODE_CLASSIC && mode !== MODE_POKER_B4,
          turnSeat: startSeat,
          trickLeaderSeat: startSeat,
          passNeed: Math.max(activeSeats.length - 1, 1),
          passStreak: 0,
          lastPlay: null,
          trickPlays: [],
          teamCall,
          finishOrder: [],
          winnerSeats: [],
          winnerSide: null,
          aiMemory: {
            playedHigh: { "2": 0, "3": 0, SJ: 0, BJ: 0 },
            bombPlays: 0
          },
          undo: null,
          winnerSeat: null,
          updatedAt: Date.now()
        };

        room.state.ready = {};
      });

      if (!tx.committed) return;
      if (!seatUids.length || !hands) return;

      try {
        await Promise.all(seatUids.map((uid) => writeHand(uid, hands[uid])));
        if (autoAiCount > 0) log(`已自动补位 ${autoAiCount} 个 AI 玩家`);
        if (mode === MODE_POKER_A4) {
          log("发牌完成，进入4人扑克A出牌阶段");
        } else if (mode === MODE_POKER_B4) {
          log("发牌完成，进入4人模式B，等待黑桃A玩家选择队友牌");
        } else if (mode === MODE_POKER_A2) {
          log("发牌完成，进入双人扑克A出牌阶段（已随机抽离10张）");
        } else if (mode === MODE_SOLO_VALIDATE) {
          log("发牌完成，进入单人验证出牌阶段");
        } else {
          log("发牌完成，进入叫分阶段");
        }
      } catch (err) {
        showMsg(`发牌写入失败：${friendlyErr(err)}`, true);
      }
    }

    async function bid(points) {
      const bidVal = Number(points);
      if (![0, 1, 2, 3].includes(bidVal)) return;
      if (!state.roomId) return;

      await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (room.status !== "bidding" || !room.state.game || !room.state.game.bid) return false;
        if ((room.state.game.mode || room.state.gameMode) !== MODE_CLASSIC) return false;

        const mySeat = getMySeat(mapRoomRow(room));
        if (mySeat === null) return false;

        const b = room.state.game.bid;
        if (b.currentSeat !== mySeat) return false;
        if (b.bids[String(mySeat)] !== null) return false;

        b.bids[String(mySeat)] = bidVal;
        b.acted += 1;

        if (bidVal > b.highestBid) {
          b.highestBid = bidVal;
          b.highestSeat = mySeat;
        }

        const activeSeats = (room.state.game.activeSeats || activeSeatsFrom(room.state.seats, room.state.seatCount))
          .filter((seat) => !!room.state.seats[String(seat)]);
        const done = b.acted >= activeSeats.length || bidVal === 3;
        if (!done) {
          b.currentSeat = nextSeat(activeSeats, mySeat);
          room.state.game.updatedAt = Date.now();
          return;
        }

        const landlordSeat = b.highestSeat === null ? activeSeats[0] : b.highestSeat;
        room.state.game.landlordSeat = landlordSeat;
        room.status = "playing";
        room.state.game.turnSeat = landlordSeat;
        room.state.game.trickLeaderSeat = landlordSeat;
        room.state.game.passNeed = Math.max(activeSeats.length - 1, 1);
        room.state.game.passStreak = 0;
        room.state.game.lastPlay = null;
        room.state.game.trickPlays = [];
        room.state.game.bottomClaimed = false;
        room.state.game.updatedAt = Date.now();
      });
    }

    async function hostGrantBottomIfNeeded() {
      const room = state.room;
      if (!room || !state.roomId) return;
      if (room.hostUid !== state.uid) return;
      if (room.status !== "playing" || !room.game || room.game.bottomClaimed) return;
      if (
        room.game.mode === MODE_POKER_A4
        || room.game.mode === MODE_POKER_A2
        || room.game.mode === MODE_POKER_B4
        || room.game.mode === MODE_SOLO_VALIDATE
      ) return;

      const landlordSeat = room.game.landlordSeat;
      const landlordUid = room.seats?.[String(landlordSeat)];
      const bottom = room.game.bottomCards || [];
      if (!landlordUid || !bottom.length) return;

      const tx = await mutateRoom(state.roomId, (work) => {
        ensureRoomStateShape(work);
        if (work.host_uid !== state.uid) return false;
        if (work.status !== "playing" || !work.state.game || work.state.game.bottomClaimed) return false;

        const seat = work.state.game.landlordSeat;
        const uid = work.state.seats[String(seat)];
        if (!uid) return false;

        work.state.publicCounts[uid] = (work.state.publicCounts[uid] || 0) + (work.state.game.bottomCards || []).length;
        work.state.game.bottomClaimed = true;
        work.state.game.updatedAt = Date.now();
      });

      if (!tx.committed) return;

      const { data: handRow } = await supabase
        .from("private_hands")
        .select("cards")
        .eq("room_id", state.roomId)
        .eq("uid", landlordUid)
        .maybeSingle();

      const merged = clone(handRow?.cards || {});
      for (const c of bottom) merged[c.id] = c;
      await writeHand(landlordUid, merged);
    }

    async function chooseTeamCard(cardId) {
      if (!state.roomId || !cardId) return;
      const targetId = String(cardId);

      const tx = await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (room.status !== "playing" || !room.state.game) return false;
        if (room.state.game.mode !== MODE_POKER_B4) return false;
        if (room.state.game.teamCall?.resolved) return false;

        const ownerSeat = room.state.game.teamCall?.ownerSeat;
        const ownerUid = room.state.seats[String(ownerSeat)];
        const mySeat = getMySeat(mapRoomRow(room));
        const selfOwner = mySeat !== null && mySeat === ownerSeat && ownerUid === state.uid;
        const hostDriveAi = room.host_uid === state.uid && isAiUid(ownerUid, { members: room.state.members });
        if (!selfOwner && !hostDriveAi) return false;

        const options = room.state.game.teamCall?.options || [];
        if (!options.includes(targetId)) return false;

        const teammateSeat = Number(room.state.game.teamCall?.seatByCard?.[targetId]);
        if (!Number.isInteger(teammateSeat)) return false;

        room.state.game.teamCall.chosenCardId = targetId;
        room.state.game.teamCall.chosenLabel = cardPrettyName(normalizeCard({ id: targetId }));
        room.state.game.teamCall.teammateSeat = teammateSeat;
        room.state.game.teamCall.resolved = true;
        room.state.game.teamCall.options = [];
        room.state.game.teamCall.seatByCard = {};
        room.state.game.bottomClaimed = true;
        room.state.game.updatedAt = Date.now();
      });

      if (!tx.committed) {
        showMsg("选择队友牌失败，请重试", true);
        return;
      }
      showMsg("已确认模式B队友牌");
      log("黑桃A玩家已完成模式B队友牌选择");
    }

    function finalizeAfterPlay(room, liveMode, liveSeats, actorSeat, actorUid) {
      if (room.state.publicCounts[actorUid] !== 0) {
        room.state.game.turnSeat = nextSeat(liveSeats, actorSeat);
        room.state.game.updatedAt = Date.now();
        return false;
      }

      const finishOrder = Array.isArray(room.state.game.finishOrder) ? room.state.game.finishOrder : [];
      if (!finishOrder.includes(actorSeat)) finishOrder.push(actorSeat);
      room.state.game.finishOrder = finishOrder;

      if (liveMode === MODE_CLASSIC) {
        const landlordSeat = room.state.game.landlordSeat;
        const winnerSeats = actorSeat === landlordSeat
          ? [landlordSeat]
          : (liveSeats.filter((s) => s !== landlordSeat));
        room.status = "finished";
        room.state.game.winnerSeat = winnerSeats[0];
        room.state.game.winnerSeats = winnerSeats;
        room.state.game.winnerSide = actorSeat === landlordSeat ? "landlord" : "farmers";
        room.state.game.updatedAt = Date.now();
        return true;
      }

      if (liveMode === MODE_POKER_B4) {
        const ownerSeat = room.state.game.teamCall?.ownerSeat;
        const mateSeat = room.state.game.teamCall?.teammateSeat;
        const hasPair = Number.isInteger(ownerSeat) && Number.isInteger(mateSeat);
        if (hasPair) {
          const pairSeats = [ownerSeat, mateSeat];
          const oppSeats = liveSeats.filter((s) => !pairSeats.includes(s));
          const pairDone = pairSeats.every((s) => finishOrder.includes(s));
          const oppDone = oppSeats.some((s) => finishOrder.includes(s));

          if (pairDone || oppDone) {
            room.status = "finished";
            if (pairDone && !oppDone) {
              room.state.game.winnerSide = "team_b_pair";
              room.state.game.winnerSeats = pairSeats;
              room.state.game.winnerSeat = pairSeats[0];
            } else {
              room.state.game.winnerSide = "team_b_opp";
              room.state.game.winnerSeats = oppSeats;
              room.state.game.winnerSeat = oppSeats[0];
            }
            room.state.game.updatedAt = Date.now();
            return true;
          }
        }

        const aliveSeats = liveSeats.filter((seat) => {
          const uid = room.state.seats[String(seat)];
          return (room.state.publicCounts[uid] || 0) > 0;
        });
        const nextLead = aliveSeats.length ? nextSeat(aliveSeats, actorSeat) : actorSeat;
        room.state.game.activeSeats = aliveSeats;
        room.state.game.passNeed = Math.max(aliveSeats.length - 1, 1);
        room.state.game.turnSeat = nextLead;
        room.state.game.trickLeaderSeat = nextLead;
        room.state.game.lastPlay = null;
        room.state.game.passStreak = 0;
        room.state.game.updatedAt = Date.now();
        return false;
      }

      room.status = "finished";
      room.state.game.winnerSeat = actorSeat;
      room.state.game.winnerSeats = [actorSeat];
      room.state.game.winnerSide = liveMode === MODE_SOLO_VALIDATE ? "solo" : "single";
      room.state.game.updatedAt = Date.now();
      return true;
    }

    async function fetchHandByUid(uid) {
      if (!supabase || !state.roomId || !uid) return {};
      const { data, error } = await supabase
        .from("private_hands")
        .select("cards")
        .eq("room_id", state.roomId)
        .eq("uid", uid)
        .maybeSingle();
      if (error && error.code !== "PGRST116") throw error;
      return data?.cards || {};
    }

    function aiAnalyzeSort(a, b) {
      const aBomb = isBombType(a.type) ? 1 : 0;
      const bBomb = isBombType(b.type) ? 1 : 0;
      if (aBomb !== bBomb) return aBomb - bBomb;
      if (a.mainValue !== b.mainValue) return a.mainValue - b.mainValue;
      if (a.length !== b.length) return a.length - b.length;
      return String(a.type).localeCompare(String(b.type));
    }

    function aiStraightSort(a, b) {
      if (a.length !== b.length) return a.length - b.length;
      return a.mainValue - b.mainValue;
    }

    function aiPairSort(a, b) {
      const av = POKER_A_VALUE[a.rankKey] || 0;
      const bv = POKER_A_VALUE[b.rankKey] || 0;
      return av - bv;
    }

    function isHighThreatPlay(lastPlay) {
      if (!lastPlay) return false;
      if (isBombType(lastPlay.type)) return true;
      return Number(lastPlay.mainValue || 0) >= (POKER_A_VALUE["2"] || 12);
    }

    function countHighRanksInHand(handMap) {
      const cnt = { "2": 0, "3": 0, SJ: 0, BJ: 0 };
      for (const card of Object.values(handMap || {})) {
        if (card.rank in cnt) cnt[card.rank] += 1;
      }
      return cnt;
    }

    function estimateHighThreatRemaining(game, handMap) {
      const total = { "2": 4, "3": 4, SJ: 1, BJ: 1 };
      const played = game?.aiMemory?.playedHigh || {};
      const mine = countHighRanksInHand(handMap);
      let remain = 0;
      for (const key of Object.keys(total)) {
        remain += Math.max(total[key] - (played[key] || 0) - (mine[key] || 0), 0);
      }
      return remain;
    }

    function shouldBombOnNormal(lastPlay, bomb, handMap, game) {
      const handSize = Object.keys(handMap || {}).length;
      const afterSize = Math.max(handSize - (bomb?.cards?.length || 0), 0);
      if (handSize <= 2 || afterSize <= 2) return true;

      if (!isHighThreatPlay(lastPlay)) return false;
      const remainHigh = estimateHighThreatRemaining(game, handMap);
      return remainHigh > 0;
    }

    function updateAiMemoryWithPlay(game, analyzed) {
      if (!game || !analyzed || !Array.isArray(analyzed.cards)) return;
      game.aiMemory = game.aiMemory || {
        playedHigh: { "2": 0, "3": 0, SJ: 0, BJ: 0 },
        bombPlays: 0
      };
      for (const card of analyzed.cards) {
        if (card.rank === "2" || card.rank === "3" || card.rank === "SJ" || card.rank === "BJ") {
          game.aiMemory.playedHigh[card.rank] = (game.aiMemory.playedHigh[card.rank] || 0) + 1;
        }
      }
      if (isBombType(analyzed.type)) {
        game.aiMemory.bombPlays = (game.aiMemory.bombPlays || 0) + 1;
      }
    }

    function enumeratePokerAAnalyzed(handMap) {
      const cards = Object.values(handMap || {});
      if (!cards.length) return [];

      const groups = {};
      for (const card of cards) {
        groups[card.rank] = groups[card.rank] || [];
        groups[card.rank].push(card);
      }
      for (const arr of Object.values(groups)) {
        arr.sort((a, b) => a.id.localeCompare(b.id));
      }

      const raw = [];
      for (const card of cards) raw.push([card]);
      for (const rank of Object.keys(groups)) {
        const arr = groups[rank];
        if (arr.length >= 2) raw.push(arr.slice(0, 2));
        if (arr.length >= 3) raw.push(arr.slice(0, 3));
        if (arr.length >= 4) raw.push(arr.slice(0, 4));
      }
      if (groups.SJ?.length && groups.BJ?.length) raw.push([groups.SJ[0], groups.BJ[0]]);

      for (let start = 0; start < POKER_A_STRAIGHT_ORDER.length; start += 1) {
        let end = start;
        while (end < POKER_A_STRAIGHT_ORDER.length && (groups[POKER_A_STRAIGHT_ORDER[end]] || []).length >= 1) end += 1;
        const runLen = end - start;
        if (runLen >= 3) {
          for (let len = 3; len <= runLen; len += 1) {
            for (let s = start; s <= end - len; s += 1) {
              const pick = [];
              for (let i = s; i < s + len; i += 1) {
                pick.push(groups[POKER_A_STRAIGHT_ORDER[i]][0]);
              }
              raw.push(pick);
            }
          }
        }
        start = end;
      }

      for (let start = 0; start < POKER_A_STRAIGHT_ORDER.length; start += 1) {
        let end = start;
        while (end < POKER_A_STRAIGHT_ORDER.length && (groups[POKER_A_STRAIGHT_ORDER[end]] || []).length >= 2) end += 1;
        const runLen = end - start;
        if (runLen >= 3) {
          for (let len = 3; len <= runLen; len += 1) {
            for (let s = start; s <= end - len; s += 1) {
              const pick = [];
              for (let i = s; i < s + len; i += 1) {
                pick.push(groups[POKER_A_STRAIGHT_ORDER[i]][0], groups[POKER_A_STRAIGHT_ORDER[i]][1]);
              }
              raw.push(pick);
            }
          }
        }
        start = end;
      }

      const uniq = new Map();
      for (const combo of raw) {
        const analyzed = analyzePokerA(combo);
        if (!analyzed.ok) continue;
        const key = combo.map((c) => c.id).sort().join(",");
        if (!uniq.has(key)) uniq.set(key, analyzed);
      }
      return Array.from(uniq.values()).sort(aiAnalyzeSort);
    }

    function pickAiClassicPlay(handMap, lastPlay, seat) {
      const cards = sortedCardsByMode(Object.values(handMap || {}), MODE_CLASSIC);
      if (!cards.length) return null;
      if (!lastPlay || lastPlay.seat === seat) {
        const c = cards[0];
        return { analyzed: { ok: true, type: "single", length: 1, mainValue: c.power, rankKey: c.rank, cards: [c] } };
      }
      const target = Number(lastPlay.power || 0);
      const higher = cards.find((c) => Number(c.power || 0) > target);
      if (!higher) return { pass: true };
      return { analyzed: { ok: true, type: "single", length: 1, mainValue: higher.power, rankKey: higher.rank, cards: [higher] } };
    }

    function pickAiPokerAPlay(handMap, lastPlay, activeSeats, seat, game) {
      const analyzedList = enumeratePokerAAnalyzed(handMap);
      if (!analyzedList.length) return { pass: true };
      const handSize = Object.keys(handMap || {}).length;
      const byType = (t) => analyzedList.filter((x) => x.type === t);
      const bombs = analyzedList.filter((x) => isBombType(x.type)).sort(aiAnalyzeSort);

      if (!lastPlay || lastPlay.seat === seat) {
        // 手牌可一次出完时优先直接清空
        const oneShot = analyzedList.find((x) => x.cards.length === handSize);
        if (oneShot) return { analyzed: oneShot };

        const straights = byType("straight").sort(aiStraightSort);
        if (straights.length) return { analyzed: straights[0] };

        const seqPairs = byType("seq_pair").sort(aiStraightSort);
        if (seqPairs.length) return { analyzed: seqPairs[0] };

        const pairs = byType("pair").sort(aiPairSort);
        const non23Pairs = pairs.filter((x) => x.rankKey !== "2" && x.rankKey !== "3");
        if (non23Pairs.length) return { analyzed: non23Pairs[0] };
        if (pairs.length) return { analyzed: pairs[0] };

        const singles = byType("single").sort(aiPairSort);
        if (singles.length) return { analyzed: singles[0] };

        // 只有炸弹时，少牌优先出最小炸弹；其余尽量后手留炸弹（但先手无法过，只能出）
        if (bombs.length) return { analyzed: bombs[0] };
        return { pass: true };
      }

      // 上家普通牌：先最小同型压制；不行再按条件考虑炸弹
      if (!isBombType(lastPlay.type)) {
        const sameType = analyzedList
          .filter((x) => x.type === lastPlay.type)
          .filter((x) => {
            if (x.type === "straight" || x.type === "seq_pair") return x.length === lastPlay.length;
            return true;
          })
          .filter((x) => canBeatPokerA(x, lastPlay, seat))
          .sort(aiAnalyzeSort);
        if (sameType.length) return { analyzed: sameType[0] };

        const bombBeat = bombs.filter((x) => canBeatPokerA(x, lastPlay, seat)).sort(aiAnalyzeSort);
        if (bombBeat.length && shouldBombOnNormal(lastPlay, bombBeat[0], handMap, game)) return { analyzed: bombBeat[0] };
        return { pass: true };
      }

      // 上家三炸：优先44捕获，再最小可压炸弹
      if (lastPlay.type === "triple_bomb") {
        const capturePairs = byType("pair").filter((x) => canCaptureInPokerA(x, lastPlay, activeSeats, seat)).sort(aiAnalyzeSort);
        if (capturePairs.length) {
          const highBomb = Number(lastPlay.mainValue || 0) >= (POKER_A_VALUE["2"] || 12);
          if (highBomb || handSize >= 8) return { analyzed: capturePairs[0] };
        }

        const bombBeat = bombs.filter((x) => canBeatPokerA(x, lastPlay, seat)).sort(aiAnalyzeSort);
        if (bombBeat.length) return { analyzed: bombBeat[0] };
        return { pass: true };
      }

      // 上家四炸：优先444捕获，再最小可压四炸
      if (lastPlay.type === "quad_bomb") {
        const captureTriple = byType("triple_bomb").filter((x) => canCaptureInPokerA(x, lastPlay, activeSeats, seat)).sort(aiAnalyzeSort);
        if (captureTriple.length) {
          const highBomb = Number(lastPlay.mainValue || 0) >= (POKER_A_VALUE["2"] || 12);
          if (highBomb || handSize >= 8) return { analyzed: captureTriple[0] };
        }
        const bombBeat = bombs.filter((x) => canBeatPokerA(x, lastPlay, seat)).sort(aiAnalyzeSort);
        if (bombBeat.length) return { analyzed: bombBeat[0] };
        return { pass: true };
      }

      // 其余炸弹（含王炸）统一按最小可压炸弹处理
      const captures = analyzedList.filter((x) => canCaptureInPokerA(x, lastPlay, activeSeats, seat));
      if (captures.length) return { analyzed: captures[0] };

      const beats = bombs.filter((x) => canBeatPokerA(x, lastPlay, seat));
      if (!beats.length) return { pass: true };
      return { analyzed: beats.sort(aiAnalyzeSort)[0] };
    }

    async function aiPassTurn(actorUid, actorSeat) {
      const tx = await mutateRoomAndHandAtomic(
        state.roomId,
        {
          actorUid,
          actorSeat,
          requirePlaying: true,
          requireBottomClaimed: true
        },
        (room) => {
        ensureRoomStateShape(room);
        if (room.status !== "playing" || !room.state.game || !room.state.game.bottomClaimed) return false;
        if (room.state.game.turnSeat !== actorSeat) return false;
        if (room.state.seats[String(actorSeat)] !== actorUid) return false;
        if (!room.state.game.lastPlay || room.state.game.trickLeaderSeat === actorSeat) return false;

        room.state.game.passStreak += 1;
        const liveSeats = (room.state.game.activeSeats || activeSeatsFrom(room.state.seats, room.state.seatCount))
          .filter((seat) => !!room.state.seats[String(seat)]);
        const passNeed = room.state.game.passNeed || Math.max(liveSeats.length - 1, 1);

        if (room.state.game.passStreak >= passNeed) {
          room.state.game.turnSeat = room.state.game.trickLeaderSeat;
          room.state.game.lastPlay = null;
          room.state.game.passStreak = 0;
        } else {
          room.state.game.turnSeat = nextSeat(liveSeats, actorSeat);
        }
        room.state.game.undo = null;
        room.state.game.updatedAt = Date.now();
      });
      return !!tx.committed;
    }

    async function aiPlayTurn(actorUid, actorSeat, analyzed, handMap) {
      const nextHand = clone(handMap || {});
      for (const card of analyzed.cards || []) delete nextHand[card.id];
      let finalHand = clone(nextHand);

      const tx = await mutateRoomAndHandAtomic(
        state.roomId,
        {
          actorUid,
          actorSeat,
          requirePlaying: true,
          requireBottomClaimed: true,
          handUid: actorUid
        },
        (room) => {
        ensureRoomStateShape(room);
        if (room.status !== "playing" || !room.state.game || !room.state.game.bottomClaimed) return false;
        if (room.state.game.turnSeat !== actorSeat) return false;
        if (room.state.seats[String(actorSeat)] !== actorUid) return false;

        const liveMode = room.state.game.mode || room.state.gameMode || MODE_CLASSIC;
        const liveSeats = (room.state.game.activeSeats || activeSeatsFrom(room.state.seats, room.state.seatCount))
          .filter((seat) => !!room.state.seats[String(seat)]);
        const lastPlay = room.state.game.lastPlay;

        if (liveMode === MODE_POKER_A4 || liveMode === MODE_POKER_A2 || liveMode === MODE_POKER_B4 || liveMode === MODE_SOLO_VALIDATE) {
          const capture = canCaptureInPokerA(analyzed, lastPlay, liveSeats, actorSeat);
          if (!capture && !canBeatPokerA(analyzed, lastPlay, actorSeat)) return false;
          room.state.publicCounts[actorUid] = Math.max((room.state.publicCounts[actorUid] || 0) - analyzed.cards.length, 0);
          if (capture) {
            const rawCards = Array.isArray(lastPlay?.cards) ? lastPlay.cards : [lastPlay];
            const capturedCards = rawCards.map((x) => normalizeCard(x)).filter(Boolean);
            room.state.publicCounts[actorUid] += capturedCards.length;
            finalHand = clone(nextHand);
            for (const card of capturedCards) finalHand[card.id] = card;
          } else {
            finalHand = clone(nextHand);
          }
        } else {
          if (!canBeatClassic(analyzed, lastPlay, actorSeat)) return false;
          room.state.publicCounts[actorUid] = Math.max((room.state.publicCounts[actorUid] || 0) - 1, 0);
          finalHand = clone(nextHand);
        }

        const labels = analyzed.cards.map((c) => c.label || cardPrettyName(c)).join(" ");
        const playRecord = {
          seat: actorSeat,
          uid: actorUid,
          type: analyzed.type,
          length: analyzed.length,
          mainValue: analyzed.mainValue,
          rankKey: analyzed.rankKey,
          cards: analyzed.cards,
          label: labels,
          power: analyzed.mainValue,
          at: Date.now()
        };
        room.state.game.lastPlay = playRecord;
        appendPlayedHistory(room.state.game, playRecord);
        updateAiMemoryWithPlay(room.state.game, analyzed);
        room.state.game.trickLeaderSeat = actorSeat;
        room.state.game.passStreak = 0;
        room.state.game.undo = null;
        finalizeAfterPlay(room, liveMode, liveSeats, actorSeat, actorUid);
        return { handCards: finalHand };
      });

      if (!tx.committed) {
        return false;
      }
      return true;
    }

    async function aiBidIfNeeded(room) {
      if (!room?.game?.bid) return false;
      const seat = room.game.bid.currentSeat;
      const uid = room.seats?.[String(seat)];
      if (!isAiUid(uid, room)) return false;

      const tx = await mutateRoom(state.roomId, (work) => {
        ensureRoomStateShape(work);
        if (work.status !== "bidding" || !work.state.game || !work.state.game.bid) return false;
        const b = work.state.game.bid;
        const s = b.currentSeat;
        const u = work.state.seats[String(s)];
        if (!isAiUid(u, { members: work.state.members })) return false;
        if (b.bids[String(s)] !== null) return false;

        const highest = Number(b.highestBid || 0);
        const r = Math.random();
        let aiBid = 0;
        if (highest === 0) aiBid = r < 0.22 ? 1 : (r < 0.28 ? 2 : (r < 0.31 ? 3 : 0));
        else if (highest === 1) aiBid = r < 0.22 ? 2 : (r < 0.28 ? 3 : 0);
        else if (highest === 2) aiBid = r < 0.18 ? 3 : 0;

        b.bids[String(s)] = aiBid;
        b.acted += 1;
        if (aiBid > b.highestBid) {
          b.highestBid = aiBid;
          b.highestSeat = s;
        }

        const activeSeats = (work.state.game.activeSeats || activeSeatsFrom(work.state.seats, work.state.seatCount))
          .filter((x) => !!work.state.seats[String(x)]);
        const done = b.acted >= activeSeats.length || aiBid === 3;
        if (!done) {
          b.currentSeat = nextSeat(activeSeats, s);
          work.state.game.updatedAt = Date.now();
          return;
        }

        const landlordSeat = b.highestSeat === null ? activeSeats[0] : b.highestSeat;
        work.state.game.landlordSeat = landlordSeat;
        work.status = "playing";
        work.state.game.turnSeat = landlordSeat;
        work.state.game.trickLeaderSeat = landlordSeat;
        work.state.game.passNeed = Math.max(activeSeats.length - 1, 1);
        work.state.game.passStreak = 0;
        work.state.game.lastPlay = null;
        work.state.game.trickPlays = [];
        work.state.game.bottomClaimed = false;
        work.state.game.updatedAt = Date.now();
      });
      return !!tx.committed;
    }

    async function aiChooseTeamCardIfNeeded(room) {
      if (!room?.game?.teamCall || room.game.teamCall.resolved) return false;
      const ownerSeat = room.game.teamCall.ownerSeat;
      const ownerUid = room.seats?.[String(ownerSeat)];
      if (!isAiUid(ownerUid, room)) return false;
      const pick = room.game.teamCall.options?.[0];
      if (!pick) return false;
      await chooseTeamCard(pick);
      return true;
    }

    async function aiPlayIfNeeded(room) {
      if (!room?.game || room.status !== "playing" || !room.game.bottomClaimed) return false;
      const actorSeat = room.game.turnSeat;
      const actorUid = room.seats?.[String(actorSeat)];
      if (!isAiUid(actorUid, room)) return false;

      const handMap = await fetchHandByUid(actorUid);
      const mode = roomMode(room);
      const liveSeats = (room.game.activeSeats || activeSeatsFrom(room.seats, room.seatCount))
        .filter((seat) => !!room.seats[String(seat)]);
      const lastPlay = room.game.lastPlay;

      const decision = mode === MODE_CLASSIC
        ? pickAiClassicPlay(handMap, lastPlay, actorSeat)
        : pickAiPokerAPlay(handMap, lastPlay, liveSeats, actorSeat, room.game);

      if (!decision || decision.pass) {
        const passed = await aiPassTurn(actorUid, actorSeat);
        if (passed) log(`AI(${actorSeat + 1}号位) 过牌`);
        return passed;
      }

      const ok = await aiPlayTurn(actorUid, actorSeat, decision.analyzed, handMap);
      if (ok) log(`AI(${actorSeat + 1}号位) 出牌：${decision.analyzed.cards.map((c) => c.label || cardPrettyName(c)).join(" ")}`);
      return ok;
    }

    async function maybeDriveAi() {
      if (state.aiBusy || !state.room || !state.roomId || !supabase) return;
      if (state.room.hostUid !== state.uid) return;

      const room = state.room;
      const mode = roomMode(room);
      if (!room.game) return;

      state.aiBusy = true;
      try {
        let acted = false;
        if (room.status === "bidding" && mode === MODE_CLASSIC) {
          acted = await aiBidIfNeeded(room);
        } else if (room.status === "playing") {
          if (mode === MODE_POKER_B4 && !room.game.bottomClaimed) {
            acted = await aiChooseTeamCardIfNeeded(room);
          }
          if (!acted) acted = await aiPlayIfNeeded(room);
        }
        if (acted) await refreshRoomAndHand(false);
      } catch (err) {
        log(`AI操作失败：${friendlyErr(err)}`);
      } finally {
        state.aiBusy = false;
      }
    }

    async function playSelected() {
      if (!state.roomId || !state.room) return;
      const beforeHand = clone(state.hand || {});
      const selectedIds = [...new Set(state.selectedCardIds)].filter((id) => !!state.hand?.[id]);
      if (!selectedIds.length) {
        showMsg("请先选择要出的牌", true);
        return;
      }

      const mode = roomMode(state.room);
      const selectedCards = selectedIds.map((id) => state.hand[id]);
      const analyzed = (mode === MODE_POKER_A4 || mode === MODE_POKER_A2 || mode === MODE_POKER_B4 || mode === MODE_SOLO_VALIDATE)
        ? analyzePokerA(selectedCards)
        : analyzeClassic(selectedCards);
      if (!analyzed.ok) {
        showMsg(analyzed.reason || "牌型无效", true);
        return;
      }

      const nextHand = clone(state.hand);
      for (const id of selectedIds) delete nextHand[id];
      let finalHand = clone(nextHand);
      const mySeat = getMySeat(state.room);
      if (mySeat === null) {
        showMsg("你尚未入座，无法出牌", true);
        return;
      }
      let roomTx;
      try {
        roomTx = await mutateRoomAndHandAtomic(
          state.roomId,
          {
            actorUid: state.uid,
            actorSeat: mySeat,
            requirePlaying: true,
            requireBottomClaimed: true,
            handUid: state.uid
          },
          (room) => {
        ensureRoomStateShape(room);
        if (room.status !== "playing" || !room.state.game || !room.state.game.bottomClaimed) return false;

        const prevStatus = room.status;
        const prevPublicCounts = clone(room.state.publicCounts || {});
        const prevGame = clone(room.state.game || {});
        delete prevGame.undo;

        const liveSeat = getMySeat(mapRoomRow(room));
        if (liveSeat === null || room.state.game.turnSeat !== liveSeat) return false;
        const liveMode = room.state.game.mode || room.state.gameMode || MODE_CLASSIC;
        if (liveMode !== mode) return false;

        const liveSeats = (room.state.game.activeSeats || activeSeatsFrom(room.state.seats, room.state.seatCount))
          .filter((seat) => !!room.state.seats[String(seat)]);
        const lastPlay = room.state.game.lastPlay;
        let didCapture = false;

        if (liveMode === MODE_POKER_A4 || liveMode === MODE_POKER_A2 || liveMode === MODE_POKER_B4 || liveMode === MODE_SOLO_VALIDATE) {
          const capture = canCaptureInPokerA(analyzed, lastPlay, liveSeats, liveSeat);
          if (!capture && !canBeatPokerA(analyzed, lastPlay, liveSeat)) return false;

          room.state.publicCounts[state.uid] = Math.max((room.state.publicCounts[state.uid] || 0) - analyzed.cards.length, 0);

          if (capture) {
            didCapture = true;
            const rawCards = Array.isArray(lastPlay?.cards) ? lastPlay.cards : [lastPlay];
            const capturedCards = rawCards.map((x) => normalizeCard(x)).filter(Boolean);
            room.state.publicCounts[state.uid] += capturedCards.length;
            finalHand = clone(nextHand);
            for (const card of capturedCards) finalHand[card.id] = card;
          } else {
            finalHand = clone(nextHand);
          }
        } else {
          if (!canBeatClassic(analyzed, lastPlay, liveSeat)) return false;
          room.state.publicCounts[state.uid] = Math.max((room.state.publicCounts[state.uid] || 0) - 1, 0);
          finalHand = clone(nextHand);
        }

        const labels = analyzed.cards.map((c) => c.label || cardPrettyName(c)).join(" ");
        const playRecord = {
          seat: liveSeat,
          uid: state.uid,
          type: analyzed.type,
          length: analyzed.length,
          mainValue: analyzed.mainValue,
          rankKey: analyzed.rankKey,
          cards: analyzed.cards,
          label: labels,
          power: analyzed.mainValue,
          at: Date.now()
        };

        room.state.game.lastPlay = playRecord;
        appendPlayedHistory(room.state.game, playRecord);
        updateAiMemoryWithPlay(room.state.game, analyzed);
        room.state.game.trickLeaderSeat = liveSeat;
        room.state.game.passStreak = 0;

        const bombRelated = isBombType(analyzed.type) || isBombType(lastPlay?.type) || didCapture;
        if (!bombRelated) {
          const afterHand = clone(finalHand);
          room.state.game.undo = {
            kind: "play",
            actorUid: state.uid,
            actorSeat: liveSeat,
            beforeHand,
            afterHand,
            prevStatus,
            prevPublicCounts,
            prevGame
          };
        } else {
          room.state.game.undo = null;
        }

        finalizeAfterPlay(room, liveMode, liveSeats, liveSeat, state.uid);
        return { handCards: finalHand };
      });
      } catch (err) {
        showMsg(`出牌失败：${friendlyErr(err)}`, true);
        return;
      }

      if (!roomTx.committed) {
        showMsg(`出牌失败：${atomicReasonText(roomTx.reason)}`, true);
        return;
      }

      state.hand = finalHand;
      state.selectedCardIds = [];
      persistSelectedCards();
    }

    async function pass() {
      if (!state.roomId) return;
      const mySeat = getMySeat(state.room);
      if (mySeat === null) return;
      let tx;
      try {
        tx = await mutateRoomAndHandAtomic(
          state.roomId,
          {
            actorUid: state.uid,
            actorSeat: mySeat,
            requirePlaying: true,
            requireBottomClaimed: true
          },
          (room) => {
        ensureRoomStateShape(room);
        if (room.status !== "playing" || !room.state.game || !room.state.game.bottomClaimed) return false;

        const liveSeat = getMySeat(mapRoomRow(room));
        if (liveSeat === null || room.state.game.turnSeat !== liveSeat) return false;
        if (!room.state.game.lastPlay) return false;
        if (room.state.game.trickLeaderSeat === liveSeat) return false;

        room.state.game.passStreak += 1;
        const liveSeats = (room.state.game.activeSeats || []).filter((seat) => !!room.state.seats[String(seat)]);
        const passNeed = room.state.game.passNeed || Math.max(liveSeats.length - 1, 1);

        if (room.state.game.passStreak >= passNeed) {
          room.state.game.turnSeat = room.state.game.trickLeaderSeat;
          room.state.game.lastPlay = null;
          room.state.game.passStreak = 0;
        } else {
          room.state.game.turnSeat = nextSeat(liveSeats, liveSeat);
        }
        room.state.game.undo = null;
        room.state.game.updatedAt = Date.now();
      });
      } catch (err) {
        showMsg(`过牌失败：${friendlyErr(err)}`, true);
        return;
      }
      if (!tx.committed) {
        showMsg(`过牌失败：${atomicReasonText(tx.reason)}`, true);
        return;
      }
      state.selectedCardIds = [];
      persistSelectedCards();
    }

    async function undoLastPlay() {
      if (!state.roomId || !state.room) return;
      let snapshot = null;

      const tx = await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if ((room.status !== "playing" && room.status !== "finished") || !room.state.game || !room.state.game.undo) return false;
        const undo = room.state.game.undo;
        if (undo.kind !== "play" || undo.actorUid !== state.uid) return false;

        snapshot = clone(undo);
        room.status = undo.prevStatus || "playing";
        room.state.publicCounts = clone(undo.prevPublicCounts || room.state.publicCounts || {});
        room.state.game = clone(undo.prevGame || room.state.game);
        room.state.game.undo = null;
        room.state.game.updatedAt = Date.now();
      });

      if (!tx.committed || !snapshot) {
        showMsg("悔牌失败：当前不可悔牌", true);
        return;
      }

      try {
        await writeHand(state.uid, snapshot.beforeHand || {});
      } catch (err) {
        showMsg(`悔牌后手牌恢复失败：${friendlyErr(err)}`, true);
        return;
      }

      state.hand = clone(snapshot.beforeHand || {});
      state.selectedCardIds = [];
      persistSelectedCards();
      showMsg("已悔牌");
      log("执行悔牌，已回到上一步出牌前状态");
      render();
    }

    async function restartGame() {
      if (!state.roomId || !state.room) return;
      if (state.room.hostUid !== state.uid) {
        showMsg("仅房主可重开", true);
        return;
      }

      const tx = await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (room.host_uid !== state.uid) return false;
        room.status = "lobby";
        room.state.ready = {};
        room.state.publicCounts = {};
        room.state.game = null;
      });

      if (!tx.committed) {
        showMsg("重开失败，请重试", true);
        return;
      }

      try {
        await supabase
          .from("private_hands")
          .delete()
          .eq("room_id", state.roomId);
      } catch (err) {
        showMsg(`清理手牌失败：${friendlyErr(err)}`, true);
        return;
      }

      state.hand = {};
      state.selectedCardIds = [];
      persistSelectedCards();
      showMsg("已重开，返回大厅");
      log("房主执行重开，对局已重置");
      render();
    }

    function nameOf(uid) {
      const m = state.room?.members?.[uid];
      return m?.nick || uid?.slice(0, 6) || "-";
    }

    function seatSlotByRelative(relative, seatCount = TABLE_SEAT_COUNT) {
      if (!Number.isInteger(relative)) return "bottom";
      if (relative === 0) return "bottom";
      if (seatCount <= 1) return "bottom";
      if (seatCount === 2) return relative === 1 ? "top" : "bottom";
      if (seatCount === 3) {
        if (relative === 1) return "right";
        if (relative === 2) return "top";
        return "bottom";
      }
      if (relative === 1) return "right";
      if (relative === 2) return "top";
      if (relative === 3) return "left";
      return "bottom";
    }

    function hiddenHandHtml(count) {
      const parsed = Number(count);
      const hasNum = Number.isFinite(parsed);
      const n = hasNum ? Math.max(0, parsed) : 0;
      const stack = Math.max(1, Math.min(4, n || 1));
      const badge = hasNum ? `x${n}` : "x-";
      return `
        <div class="hidden-hand">
          <div class="hidden-hand-stack" aria-hidden="true">
            ${Array.from({ length: stack }).map((_, idx) => `<span class="hidden-hand-card" style="--idx:${idx};"></span>`).join("")}
          </div>
          <span class="hidden-hand-count">${badge}</span>
        </div>
      `;
    }

    function renderSeats() {
      const room = state.room;
      if (!room) {
        seatsWrap.classList.remove("table-view");
        seatsWrap.innerHTML = "";
        return;
      }

      const mySeat = getMySeat(room);
      const seatCount = Math.max(TABLE_SEAT_MIN, Math.min(TABLE_SEAT_COUNT, Number(room.seatCount) || TABLE_SEAT_COUNT));
      const seatIndexes = buildSeatIndexes(room.seatCount);
      const inMatch = room.status === "bidding" || room.status === "playing" || room.status === "finished";
      const tableView = !!state.landscapeUi && inMatch;
      seatsWrap.classList.toggle("table-view", tableView);
      const allowSeatActions = room.status === "lobby" || !tableView;

      const centerTurnSeat = Number.isInteger(room.game?.turnSeat) ? room.game.turnSeat : null;
      const centerTurnUid = centerTurnSeat === null ? null : room.seats?.[String(centerTurnSeat)];
      const centerTurnName = centerTurnUid ? nameOf(centerTurnUid) : "-";
      const centerLast = room.game?.lastPlay?.label || "无";
      const phaseLabel = room.status === "playing"
        ? "出牌"
        : (room.status === "bidding" ? "叫分" : (room.status === "finished" ? "结束" : "大厅"));
      const lastPlayCards = (Array.isArray(room.game?.lastPlay?.cards)
        ? room.game.lastPlay.cards
        : (room.game?.lastPlay ? [room.game.lastPlay] : []))
        .map((x) => normalizeCard(x))
        .filter(Boolean);
      const lastPlayWho = room.game?.lastPlay?.uid ? nameOf(room.game.lastPlay.uid) : "-";
      const tableInfoHtml = tableView ? `
        <div class="table-info-hud">
          <div class="line">阶段：${escapeHtml(phaseLabel)}</div>
          <div class="line">轮到：${escapeHtml(centerTurnName)}</div>
          <div class="line">最近牌：${escapeHtml(centerLast)}</div>
        </div>
      ` : "";
      const coreOn = tableView && inMatch && !!state.tableCoreUi;
      const tableLastHtml = tableView ? `
        <div class="table-last-play">
          <span class="small">${escapeHtml(lastPlayWho)}：</span>
          <div class="table-last-play-cards">
            ${lastPlayCards.length
              ? lastPlayCards.map((card) => {
                const src = cardImageUrl(card);
                const alt = escapeHtml(cardPrettyName(card));
                return `<img class="played-card" src="${src}" alt="${alt}" />`;
              }).join("")
              : `<span class="small muted">暂无出牌</span>`
            }
          </div>
        </div>
      ` : "";
      const tableCenterDockHtml = coreOn ? `<div id="tableCenterDock" class="table-center-dock"></div>` : "";

      seatsWrap.innerHTML = `${tableInfoHtml}${tableLastHtml}${tableCenterDockHtml}${seatIndexes.map((seat) => {
        const uid = room.seats?.[String(seat)] || null;
        const isMine = uid && uid === state.uid;
        const aiTag = uid && room.members?.[uid]?.isAi ? " <span class='pill'>AI</span>" : "";
        const label = uid ? `${escapeHtml(nameOf(uid))}${aiTag}` : "空位";
        const landlord = room.game?.landlordSeat === seat ? "<span class='pill'>地主</span>" : "";
        const turn = room.game?.turnSeat === seat && room.status === "playing" ? "<span class='pill'>出牌中</span>" : "";
        const remaining = uid ? (room.publicCounts?.[uid] ?? "-") : "-";
        const concealed = tableView && inMatch && uid && !isMine;
        const count = uid
          ? (concealed
            ? `<div class='seat-meta'>剩余牌：已隐藏</div>${hiddenHandHtml(remaining)}`
            : `<div class='seat-meta'>剩余牌：${remaining}</div>`)
          : "";
        const mineHandPreview = (tableView && inMatch && isMine && !coreOn)
          ? `<div class='seat-meta'>当前手牌</div>
             <div class='seat-hand-mini'>${
               sortedHandCards(state.hand || {}).map((card) => {
                 const src = cardImageUrl(card);
                 const alt = escapeHtml(cardPrettyName(card));
                 return `<img class="seat-hand-mini-card" src="${src}" alt="${alt}" />`;
               }).join("")
             }</div>`
          : "";
        const seatPlayDock = (coreOn && isMine) ? `<div id="seatPlayDock" class="seat-play-dock"></div>` : "";
        const btn = !allowSeatActions
          ? ""
          : (uid
            ? (isMine
              ? `<button data-seat='stand'>离座</button>`
              : (room.members?.[uid]?.isAi ? `<button data-seat='${seat}'>接管AI座位</button>` : ""))
            : `<button data-seat='${seat}'>入座</button>`);
        const turnClass = room.game?.turnSeat === seat && room.status === "playing" ? "turning" : "";
        const relative = mySeat === null ? seat : ((seat - mySeat + seatCount) % seatCount);
        const slot = tableView ? seatSlotByRelative(relative, seatCount) : "";
        const slotAttr = tableView ? ` data-slot="${slot}"` : "";
        const actions = btn ? `<div class="seat-actions">${btn}</div>` : "";

        return `
          <div class="seat ${mySeat === seat ? "you" : ""} ${turnClass}"${slotAttr}>
            <div class="seat-head"><strong>${seat + 1} 号位</strong><span>${landlord}${turn}</span></div>
            <div class="seat-meta">${label}</div>
            <div>${count}</div>
            ${mineHandPreview}
            ${seatPlayDock}
            ${actions}
          </div>
        `;
      }).join("")}`;

      seatsWrap.querySelectorAll("button[data-seat]").forEach((btn) => {
        btn.addEventListener("click", async () => {
          const v = btn.dataset.seat;
          if (v === "stand") {
            await seatAction(null);
            return;
          }
          await seatAction(Number(v));
        });
      });
    }

    function renderRoomInfo() {
      if (!state.room) {
        gameModeSelect.disabled = false;
        roomInfo.innerHTML = "尚未加入房间";
        return;
      }

      const room = state.room;
      const members = Object.entries(room.members || {}).sort((a, b) => (a[1].joinedAt || 0) - (b[1].joinedAt || 0));
      const seated = activeSeatsFrom(room.seats, room.seatCount).length;
      const mode = roomMode(room);
      const startRange = (mode === MODE_POKER_A4 || mode === MODE_POKER_B4)
        ? "4"
        : (mode === MODE_POKER_A2 ? "2" : (mode === MODE_SOLO_VALIDATE ? "1" : `${TABLE_MIN_PLAYERS}-${TABLE_MAX_PLAYERS}`));
      gameModeSelect.value = room.gameMode || MODE_CLASSIC;
      gameModeSelect.disabled = true;
      roomInfo.innerHTML = `
        <div>状态：<span class="pill">${escapeHtml(room.status || "-")}</span></div>
        <div>房主：${escapeHtml(nameOf(room.hostUid))}</div>
        <div>模式：${escapeHtml(modeLabel(room.gameMode))}</div>
        <div>在线人数：${members.length}/${room.maxMembers || 9}</div>
        <div>入座人数：${seated}（可开局范围：${startRange}）</div>
        <div>同步：${state.realtimeReady ? "实时通道" : "轮询"} / 网络：${state.networkOnline ? "在线" : "离线"}</div>
        <div style="margin-top: 6px;">成员：${members.map(([uid, v]) => {
          const host = uid === room.hostUid ? "(房主)" : "";
          const ai = v?.isAi ? "(AI)" : "";
          return `${escapeHtml(v.nick || uid.slice(0, 6))}${host}${ai}`;
        }).join("、")}</div>
      `;
    }

    function getWinnerSummary(room) {
      const game = room?.game || {};
      const mode = roomMode(room);
      const winnerSeats = Array.isArray(game.winnerSeats) && game.winnerSeats.length
        ? game.winnerSeats
        : (Number.isInteger(game.winnerSeat) ? [game.winnerSeat] : []);
      const winnerNames = winnerSeats
        .map((seat) => room?.seats?.[String(seat)])
        .filter(Boolean)
        .map((uid) => nameOf(uid));
      let winnerText = winnerNames.length ? `胜者：${winnerNames.join("、")}` : "胜者：待定";
      if (mode === MODE_CLASSIC) {
        if (game.winnerSide === "landlord") winnerText = `地主胜：${winnerNames.join("、") || "-"}`;
        if (game.winnerSide === "farmers") winnerText = `农民胜：${winnerNames.join("、") || "-"}`;
      }
      if (mode === MODE_POKER_B4) {
        if (game.winnerSide === "team_b_pair") winnerText = `黑桃A阵营胜：${winnerNames.join("、") || "-"}`;
        if (game.winnerSide === "team_b_opp") winnerText = `对家阵营胜：${winnerNames.join("、") || "-"}`;
      }
      return { winnerSeats, winnerNames, winnerText };
    }

    function clearVictoryTimers() {
      if (state.victoryAutoTimer) {
        clearTimeout(state.victoryAutoTimer);
        state.victoryAutoTimer = null;
      }
      for (const tid of state.victoryBurstTimers) clearTimeout(tid);
      state.victoryBurstTimers = [];
    }

    function hideVictoryCelebration() {
      clearVictoryTimers();
      victoryOverlay.classList.remove("show");
      victoryOverlay.setAttribute("aria-hidden", "true");
      victoryConfetti.innerHTML = "";
      victoryFireworks.innerHTML = "";
    }

    function spawnConfetti(count = 120) {
      const palette = ["#f44336", "#ff9800", "#ffeb3b", "#4caf50", "#2196f3", "#f06292"];
      for (let i = 0; i < count; i += 1) {
        const piece = document.createElement("span");
        piece.className = "confetti-piece";
        piece.style.left = `${Math.random() * 100}%`;
        piece.style.background = palette[Math.floor(Math.random() * palette.length)];
        piece.style.opacity = `${0.7 + Math.random() * 0.3}`;
        piece.style.animationDelay = `${Math.random() * 0.9}s`;
        piece.style.animationDuration = `${2.8 + Math.random() * 2.9}s`;
        piece.style.setProperty("--drift", `${Math.round((Math.random() * 2 - 1) * 120)}px`);
        victoryConfetti.appendChild(piece);
      }
    }

    function spawnFireworkBurst(xPct, yPct, size = 74, sparks = 14) {
      const burst = document.createElement("div");
      burst.className = "firework-burst";
      burst.style.left = `${xPct}%`;
      burst.style.top = `${yPct}%`;

      const ring = document.createElement("span");
      ring.className = "firework-ring";
      burst.appendChild(ring);

      for (let i = 0; i < sparks; i += 1) {
        const angle = ((Math.PI * 2) / sparks) * i + (Math.random() * 0.22 - 0.11);
        const dist = size * (0.62 + Math.random() * 0.48);
        const spark = document.createElement("span");
        spark.className = "firework-spark";
        spark.style.setProperty("--dx", `${Math.cos(angle) * dist}px`);
        spark.style.setProperty("--dy", `${Math.sin(angle) * dist}px`);
        spark.style.setProperty("--h", `${Math.floor(Math.random() * 360)}`);
        burst.appendChild(spark);
      }

      victoryFireworks.appendChild(burst);
      const tid = setTimeout(() => burst.remove(), 950);
      state.victoryBurstTimers.push(tid);
    }

    function launchVictoryCelebration(text) {
      hideVictoryCelebration();
      victoryText.textContent = `恭喜！${text}`;
      victoryOverlay.classList.add("show");
      victoryOverlay.setAttribute("aria-hidden", "false");
      spawnConfetti(128);

      for (let i = 0; i < 10; i += 1) {
        const tid = setTimeout(() => {
          const x = 12 + Math.random() * 76;
          const y = 18 + Math.random() * 50;
          spawnFireworkBurst(x, y, 62 + Math.random() * 26, 12 + Math.floor(Math.random() * 4));
        }, i * 230);
        state.victoryBurstTimers.push(tid);
      }

      state.victoryAutoTimer = setTimeout(() => {
        hideVictoryCelebration();
      }, 7200);
    }

    function maybeShowVictoryCelebration() {
      const room = state.room;
      if (!room || room.status !== "finished" || !room.game) {
        hideVictoryCelebration();
        return;
      }

      const mySeat = getMySeat(room);
      const { winnerSeats, winnerText } = getWinnerSummary(room);
      const key = `${state.roomId}|${room.game.round || 0}|${room.game.winnerSide || ""}|${winnerSeats.join(",")}`;
      if (!Number.isInteger(mySeat) || !winnerSeats.includes(mySeat)) return;
      if (state.victoryShownKey === key) return;

      state.victoryShownKey = key;
      launchVictoryCelebration(winnerText);
      log("胜利庆祝已触发：撒花 + 鞭炮");
    }

    function renderGame() {
      const room = state.room;
      if (!room || !room.game) {
        gameInfo.textContent = "等待开局";
        bidWrap.style.display = "none";
        playActions.style.display = "none";
        teamCallWrap.style.display = "none";
        return;
      }

      const mySeat = getMySeat(room);
      const game = room.game;
      const mode = roomMode(room);

      if (room.status === "bidding" && mode === MODE_CLASSIC) {
        const curUid = room.seats?.[String(game.bid.currentSeat)];
        const bids = game.bid.bids || {};
        const bidLabels = (game.activeSeats || []).map((seat) => `${seat + 1}号(${bids[String(seat)] ?? "-"})`).join(" / ");
        gameInfo.innerHTML = `
          <div>阶段：叫分</div>
          <div>当前：${escapeHtml(nameOf(curUid))}</div>
          <div>叫分记录：${escapeHtml(bidLabels || "-")}</div>
        `;
        bidWrap.style.display = mySeat === game.bid.currentSeat ? "flex" : "none";
        playActions.style.display = "none";
        teamCallWrap.style.display = "none";
      } else if (room.status === "playing") {
        const last = game.lastPlay ? `${game.lastPlay.label}（${nameOf(game.lastPlay.uid)}）` : "无（新一轮）";
        const landlordUid = room.seats?.[String(game.landlordSeat)];
        const turnUid = room.seats?.[String(game.turnSeat)];
        const turnTag = `<div class="turn-banner">轮到：${escapeHtml(nameOf(turnUid))}</div>`;
        if (mode === MODE_POKER_A4) {
          gameInfo.innerHTML = `
            <div>阶段：4人扑克A出牌</div>
            <div>${turnTag}</div>
            <div>最近牌：${escapeHtml(last)}</div>
          `;
        } else if (mode === MODE_POKER_A2) {
          gameInfo.innerHTML = `
            <div>阶段：双人扑克A出牌</div>
            <div>${turnTag}</div>
            <div>最近牌：${escapeHtml(last)}</div>
            <div>开牌：已随机抽离 ${(game.openedCards || []).length || 10} 张</div>
          `;
        } else if (mode === MODE_POKER_B4) {
          const callSeat = game.teamCall?.ownerSeat;
          const callUid = room.seats?.[String(callSeat)];
          const waiting = game.teamCall?.resolved
            ? `已公示队友牌：${escapeHtml(game.teamCall?.chosenLabel || "-")}`
            : `等待 ${escapeHtml(nameOf(callUid))}（黑桃A）选择队友牌`;
          gameInfo.innerHTML = `
            <div>阶段：4人模式B出牌</div>
            <div>${turnTag}</div>
            <div>最近牌：${escapeHtml(last)}</div>
            <div>${waiting}</div>
          `;
        } else if (mode === MODE_SOLO_VALIDATE) {
          gameInfo.innerHTML = `
            <div>阶段：单人验证出牌</div>
            <div>${turnTag}</div>
            <div>最近牌：${escapeHtml(last)}</div>
          `;
        } else {
          gameInfo.innerHTML = `
            <div>阶段：出牌</div>
            <div>地主：${escapeHtml(nameOf(landlordUid))}</div>
            <div>${turnTag}</div>
            <div>最近牌：${escapeHtml(last)}</div>
            <div>底牌状态：${game.bottomClaimed ? "已发放" : "房主发放中"}</div>
          `;
        }
        bidWrap.style.display = "none";
        playActions.style.display = mySeat === game.turnSeat && game.bottomClaimed ? "flex" : "none";
      } else if (room.status === "finished") {
        const { winnerText } = getWinnerSummary(room);
        const range = (mode === MODE_POKER_A4 || mode === MODE_POKER_B4)
          ? "4"
          : (mode === MODE_POKER_A2 ? "2" : (mode === MODE_SOLO_VALIDATE ? "1" : `${TABLE_MIN_PLAYERS}-${TABLE_MAX_PLAYERS}`));
        gameInfo.innerHTML = `
          <div>阶段：已结束</div>
          <div>${escapeHtml(winnerText)}</div>
          <div class="small">房主可重新开始（${range} 人选座后可直接开局）</div>
        `;
        bidWrap.style.display = "none";
        playActions.style.display = "none";
        teamCallWrap.style.display = "none";
      }
    }

    function updateHandScrollBar() {
      if (!handCards || !handScrollWrap || !handScrollBar) return;
      const max = Math.max(0, Math.round(handCards.scrollWidth - handCards.clientWidth));
      if (max <= 1) {
        handScrollWrap.style.display = "none";
        handScrollBar.max = "0";
        handScrollBar.value = "0";
        return;
      }
      handScrollWrap.style.display = "block";
      handScrollBar.max = String(max);
      handScrollBar.value = String(Math.max(0, Math.min(max, Math.round(handCards.scrollLeft || 0))));
    }

    let handScrollRaf = 0;
    function scheduleUpdateHandScrollBar() {
      if (handScrollRaf) return;
      handScrollRaf = requestAnimationFrame(() => {
        handScrollRaf = 0;
        updateHandScrollBar();
      });
    }

    function syncPlaySelectedButton(canPlay) {
      const count = Array.isArray(state.selectedCardIds) ? state.selectedCardIds.length : 0;
      playSelectedBtn.disabled = !(canPlay && count > 0);
      if (clearSelectionBtn) clearSelectionBtn.disabled = count === 0;
      if (selectedCount) selectedCount.textContent = count > 0 ? `已选 ${count} 张` : "未选中";
    }

    function renderHand() {
      const cards = sortedHandCards(state.hand);
      if (!cards.length) {
        handCards.innerHTML = '<span class="small muted">暂无手牌</span>';
        handCards.onpointerdown = null;
        handCards.onpointermove = null;
        handCards.onpointerup = null;
        handCards.onpointercancel = null;
        updateHandScrollBar();
        syncPlaySelectedButton(false);
        return;
      }

      const canPlay = state.room?.status === "playing"
        && state.room?.game?.bottomClaimed
        && getMySeat(state.room) === state.room?.game?.turnSeat;

      handCards.innerHTML = cards.map((c, idx) => {
        const id = escapeHtml(c.id);
        const title = escapeHtml(cardPrettyName(c));
        const src = cardImageUrl(c);
        const selected = state.selectedCardIds.includes(c.id) ? "selected" : "";
        return `<button class="card-btn ${selected}" data-card="${id}" title="${title}" style="z-index:${idx + 1}" ${canPlay ? "" : "disabled"}><img class="card-img" src="${src}" alt="${title}" /></button>`;
      }).join("");
      scheduleUpdateHandScrollBar();

      const buttons = [...handCards.querySelectorAll("button[data-card]")];
      const btnById = new Map(buttons.map((btn) => [btn.dataset.card, btn]));
      const selectedSet = new Set(
        (Array.isArray(state.selectedCardIds) ? state.selectedCardIds : []).filter((id) => !!state.hand?.[id])
      );
      let selectedDirty = false;

      const flushSelectedState = () => {
        if (!selectedDirty) return false;
        state.selectedCardIds = Array.from(selectedSet);
        selectedDirty = false;
        return true;
      };

      const setSelected = (id, selected) => {
        if (!id || !state.hand?.[id]) return false;
        const has = selectedSet.has(id);
        if (selected && !has) {
          selectedSet.add(id);
          selectedDirty = true;
        } else if (!selected && has) {
          selectedSet.delete(id);
          selectedDirty = true;
        } else {
          return false;
        }
        const btn = btnById.get(id);
        if (btn) btn.classList.toggle("selected", selected);
        return true;
      };

      const selectSingleByTap = (id) => {
        if (!id) return;
        const changed = setSelected(id, !selectedSet.has(id));
        if (!changed) return;
        flushSelectedState();
        persistSelectedCards();
        syncPlaySelectedButton(canPlay);
      };

      buttons.forEach((btn) => {
        btn.addEventListener("click", () => {
          if (!canPlay) return;
          if (Date.now() < state.touchHandledUntil) return;
          const id = btn.dataset.card || "";
          selectSingleByTap(id);
        });
      });

      let tapSession = null;
      const cardCenters = buttons.map((btn) => ({
        id: btn.dataset.card || "",
        center: btn.offsetLeft + (btn.offsetWidth / 2)
      })).filter((x) => !!x.id);
      const orderedIds = cardCenters.map((x) => x.id);
      const indexById = new Map(orderedIds.map((id, idx) => [id, idx]));
      const hitRanges = cardCenters.map((c, idx) => {
        const prev = idx > 0 ? cardCenters[idx - 1] : null;
        const next = idx < cardCenters.length - 1 ? cardCenters[idx + 1] : null;
        return {
          id: c.id,
          start: prev ? (prev.center + c.center) / 2 : -Infinity,
          end: next ? (c.center + next.center) / 2 : Infinity
        };
      });
      const hitCardIdByX = (clientX) => {
        if (!hitRanges.length) return "";
        const rect = handCards.getBoundingClientRect();
        const x = (clientX - rect.left) + handCards.scrollLeft;
        for (let i = 0; i < hitRanges.length; i += 1) {
          const r = hitRanges[i];
          if (x >= r.start && x < r.end) return r.id;
        }
        return hitRanges[hitRanges.length - 1]?.id || "";
      };
      const topCardIdAtPoint = (clientX, clientY) => {
        if (typeof document.elementFromPoint !== "function") return "";
        const el = document.elementFromPoint(clientX, clientY);
        if (!el) return "";
        const btn = el.closest?.("button[data-card]");
        if (!btn || !handCards.contains(btn)) return "";
        const id = btn.dataset.card || "";
        return btnById.has(id) ? id : "";
      };
      const hitCardIdByPoint = (clientX, clientY) => {
        // Prefer the top-most rendered card to avoid selecting cards under overlap.
        const topId = topCardIdAtPoint(clientX, clientY);
        if (topId) return topId;
        return hitCardIdByX(clientX);
      };
      const idsInRange = (startId, endId) => {
        const a = indexById.get(startId);
        const b = indexById.get(endId);
        if (a == null || b == null) return [];
        const from = Math.min(a, b);
        const to = Math.max(a, b);
        return orderedIds.slice(from, to + 1);
      };
      const paintSelectedFromSet = (set) => {
        buttons.forEach((btn) => {
          const id = btn.dataset.card || "";
          btn.classList.toggle("selected", set.has(id));
        });
      };
      const buildRangeSet = (baseSet, startId, endId, action) => {
        const nextSet = new Set(baseSet);
        const ids = idsInRange(startId, endId);
        ids.forEach((id) => {
          if (action === "remove") nextSet.delete(id);
          else nextSet.add(id);
        });
        return nextSet;
      };
      const paintPreviewRange = (session) => {
        if (!session?.anchorId || !session?.hoverId) {
          paintSelectedFromSet(selectedSet);
          return;
        }
        const previewSet = buildRangeSet(
          session.baseSelected,
          session.anchorId,
          session.hoverId,
          session.rangeAction
        );
        paintSelectedFromSet(previewSet);
      };
      const applySelectionSet = (nextSet) => {
        let changed = false;
        Array.from(selectedSet).forEach((id) => {
          if (!nextSet.has(id)) changed = setSelected(id, false) || changed;
        });
        nextSet.forEach((id) => {
          if (!selectedSet.has(id)) changed = setSelected(id, true) || changed;
        });
        return changed;
      };

      if (canPlay) {
        handCards.onpointerdown = (evt) => {
          if (evt.pointerType === "mouse") return;
          if (evt.button != null && evt.button !== 0) return;
          const anchorId = hitCardIdByPoint(evt.clientX, evt.clientY);
          if (!anchorId) return;
          tapSession = {
            pointerId: evt.pointerId,
            startX: evt.clientX,
            startY: evt.clientY,
            lastX: evt.clientX,
            lastY: evt.clientY,
            startedAt: performance.now(),
            anchorId,
            hoverId: anchorId,
            mode: "pending",
            baseSelected: new Set(selectedSet),
            rangeAction: selectedSet.has(anchorId) ? "remove" : "add"
          };
          try {
            handCards.setPointerCapture(evt.pointerId);
          } catch (_) {}
        };
        handCards.onpointermove = (evt) => {
          if (evt.pointerType === "mouse") return;
          if (!tapSession || tapSession.pointerId !== evt.pointerId) return;
          tapSession.lastX = evt.clientX;
          tapSession.lastY = evt.clientY;
          const dx = evt.clientX - tapSession.startX;
          const dy = evt.clientY - tapSession.startY;
          const adx = Math.abs(dx);
          const ady = Math.abs(dy);
          if (tapSession.mode === "pending") {
            // Axis lock: horizontal drag enters range-select, vertical drag keeps native scroll.
            if (ady >= 14 && ady > adx + 8) {
              tapSession.mode = "scroll";
              return;
            }
            if (adx < 10 || adx < ady + 6) return;
            tapSession.mode = "range";
            paintPreviewRange(tapSession);
          }
          if (tapSession.mode !== "range") return;
          const id = hitCardIdByPoint(evt.clientX, evt.clientY);
          if (id && id !== tapSession.hoverId) {
            tapSession.hoverId = id;
            paintPreviewRange(tapSession);
          }
          evt.preventDefault();
        };
        handCards.onpointerup = (evt) => {
          if (evt.pointerType === "mouse") return;
          if (!tapSession || tapSession.pointerId !== evt.pointerId) return;
          const session = tapSession;
          tapSession = null;
          try {
            if (handCards.hasPointerCapture?.(evt.pointerId)) handCards.releasePointerCapture(evt.pointerId);
          } catch (_) {}
          if (session.mode === "range") {
            const finalSet = buildRangeSet(
              session.baseSelected,
              session.anchorId,
              session.hoverId,
              session.rangeAction
            );
            const changed = applySelectionSet(finalSet);
            if (changed) {
              flushSelectedState();
              persistSelectedCards();
              syncPlaySelectedButton(canPlay);
            } else {
              paintSelectedFromSet(selectedSet);
            }
            state.touchHandledUntil = Date.now() + 360;
            evt.preventDefault();
            return;
          }
          if (session.mode === "scroll") {
            state.touchHandledUntil = Date.now() + 220;
            paintSelectedFromSet(selectedSet);
            return;
          }
          const dx = Math.abs(evt.clientX - session.startX);
          const dy = Math.abs(evt.clientY - session.startY);
          const dt = performance.now() - session.startedAt;
          if (dx > 10 || dy > 10 || dt > 360) {
            state.touchHandledUntil = Date.now() + 220;
            return;
          }
          if (!session.anchorId) return;
          state.touchHandledUntil = Date.now() + 360;
          selectSingleByTap(session.anchorId);
          evt.preventDefault();
        };
        handCards.onpointercancel = (evt) => {
          if (tapSession && evt && tapSession.pointerId === evt.pointerId) {
            try {
              if (handCards.hasPointerCapture?.(evt.pointerId)) handCards.releasePointerCapture(evt.pointerId);
            } catch (_) {}
          }
          paintSelectedFromSet(selectedSet);
          tapSession = null;
        };
      } else {
        handCards.onpointerdown = null;
        handCards.onpointermove = null;
        handCards.onpointerup = null;
        handCards.onpointercancel = null;
      }

      syncPlaySelectedButton(canPlay);
    }

    function renderButtons() {
      const room = state.room;
      const mySeat = getMySeat(room);
      const isHost = room?.hostUid === state.uid;
      const mode = roomMode(room);

      const activeSeats = room ? activeSeatsFrom(room.seats, room.seatCount) : [];
      const seatOk = (mode === MODE_POKER_A4 || mode === MODE_POKER_B4)
        ? activeSeats.length === 4
        : (mode === MODE_POKER_A2
          ? activeSeats.length === 2
          : (mode === MODE_SOLO_VALIDATE
          ? activeSeats.length === 1
          : (activeSeats.length >= TABLE_MIN_PLAYERS && activeSeats.length <= TABLE_MAX_PLAYERS)));
      startBtn.disabled = !(room && isHost && room.status === "lobby" && mySeat !== null && activeSeats.length >= 1);
      hostTakeoverBtn.disabled = !(room && room.members && !room.members[room.hostUid] && room.members[state.uid]);
      playSelectedBtn.disabled = !(room && room.status === "playing" && mySeat === room.game?.turnSeat && room.game?.bottomClaimed && state.selectedCardIds.length > 0);
      passBtn.disabled = !(room && room.status === "playing" && mySeat === room.game?.turnSeat && room.game?.lastPlay && room.game?.trickLeaderSeat !== mySeat);
      undoBtn.disabled = !(room && (room.status === "playing" || room.status === "finished") && room.game?.undo && room.game.undo.actorUid === state.uid);
      restartBtn.disabled = !(room && room.hostUid === state.uid);
      closeRoomBtn.disabled = !(room && room.hostUid === state.uid);
      const count = Array.isArray(state.selectedCardIds) ? state.selectedCardIds.length : 0;
      clearSelectionBtn.disabled = count === 0;
      selectedCount.textContent = count > 0 ? `已选 ${count} 张` : "未选中";
    }

    function playedEntryId(play, serial) {
      const at = Number(play?.at || 0);
      const uid = String(play?.uid || "");
      const seat = Number.isInteger(play?.seat) ? play.seat : -1;
      const label = String(play?.label || "");
      return `${serial}|${at}|${seat}|${uid}|${label}`;
    }

    function setPlayedNowHtml(html) {
      const prevX = Number(playedNow.scrollLeft || 0);
      const prevY = Number(playedNow.scrollTop || 0);
      const sameRoom = state.playedScrollRoom === (state.roomId || "");
      playedNow.innerHTML = html;
      requestAnimationFrame(() => {
        if (sameRoom && (prevX || prevY)) {
          playedNow.scrollLeft = prevX;
          playedNow.scrollTop = prevY;
        } else {
          restorePlayedWindowPos();
        }
      });
      state.playedScrollRoom = state.roomId || "";
      scheduleSavePlayedWindowPos();
    }

    function renderPlayedWindow() {
      const room = state.room;
      if (!room || !room.game) {
        if (playedTitle) playedTitle.textContent = "上一个玩家出的牌";
        state.playedRenderIds = [];
        state.playedRenderRoom = "";
        setPlayedNowHtml('<span class="small muted">等待对局开始</span>');
        return;
      }

      const mode = roomMode(room);
      const coreOn = !!state.landscapeUi
        && !!state.tableCoreUi
        && (room.status === "playing" || room.status === "bidding" || room.status === "finished");
      const limitN = coreOn ? 1 : playedWindowLimit(room);
      if (playedTitle) {
        if (coreOn) {
          playedTitle.textContent = "中区出牌";
        } else if (room.status === "playing") {
          playedTitle.textContent = `最近 ${limitN} 手（轮替显示）`;
        } else if (room.status === "finished") {
          playedTitle.textContent = `对局结束回顾（最近 ${limitN} 手）`;
        } else {
          playedTitle.textContent = "出牌记录";
        }
      }
      let extra = "";
      if (mode === MODE_POKER_B4 && room.game.teamCall?.resolved && room.game.teamCall?.chosenCardId && !coreOn) {
        const ownerSeat = room.game.teamCall?.ownerSeat;
        const ownerUid = room.game.teamCall?.ownerUid || room.seats?.[String(ownerSeat)];
        const ownerName = escapeHtml(ownerUid ? nameOf(ownerUid) : (Number.isInteger(ownerSeat) ? `${ownerSeat + 1}号位` : "未知"));
        const card = normalizeCard({ id: room.game.teamCall.chosenCardId });
        const src = cardImageUrl(card);
        const alt = escapeHtml(cardPrettyName(card));
        extra = `
          <div class="played-call-row">
            <div class="played-owner-chip">
              <div class="small muted">黑桃A玩家</div>
              <div class="played-owner-name">${ownerName}</div>
            </div>
            <div class="played-chip">
              <img class="played-card played-card-call" src="${src}" alt="${alt}" />
              <div class="played-cap played-cap-call">模式B队友牌（队友未公开）</div>
            </div>
          </div>
        `;
      }

      const trickPlays = Array.isArray(room.game.trickPlays) ? room.game.trickPlays : [];
      if (!trickPlays.length) {
        state.playedRenderIds = [];
        state.playedRenderRoom = state.roomId || "";
        const last = room.game.lastPlay;
        if (!last) {
          setPlayedNowHtml(`${extra}<span class="small muted">暂无出牌记录</span>`);
          return;
        }
        const cards = (Array.isArray(last.cards) ? last.cards : [last]).map((x) => normalizeCard(x)).filter(Boolean);
        if (!cards.length) {
          setPlayedNowHtml(`${extra}<span class="small muted">暂无可显示的出牌</span>`);
          return;
        }
        const who = escapeHtml(last.uid === state.uid ? "你" : nameOf(last.uid));
        setPlayedNowHtml(`${extra}
          <div class="small muted">旧房间兼容：仅显示最近一手</div>
          ${cards.map((card) => {
            const src = cardImageUrl(card);
            const alt = escapeHtml(cardPrettyName(card));
            return `
              <div class="played-chip">
                <img class="played-card" src="${src}" alt="${alt}" />
                <div class="played-cap">${who}</div>
              </div>
            `;
          }).join("")}
        `);
        return;
      }

      const shownPlays = trickPlays.slice(-limitN);
      const offset = trickPlays.length - shownPlays.length;
      const curIds = shownPlays.map((play, idx) => playedEntryId(play, offset + idx + 1));
      const sameRoom = state.playedRenderRoom === (state.roomId || "");
      const prevIds = sameRoom ? state.playedRenderIds : [];
      const newIdSet = new Set(prevIds.length ? curIds.filter((id) => !prevIds.includes(id)) : []);
      state.playedRenderIds = curIds;
      state.playedRenderRoom = state.roomId || "";
      const tip = (!coreOn && trickPlays.length > shownPlays.length)
        ? `<div class="small muted">共 ${trickPlays.length} 手，当前轮替显示最近 ${shownPlays.length} 手</div>`
        : "";

      setPlayedNowHtml(`${extra}${tip}${shownPlays.map((play, idx) => {
        const id = curIds[idx];
        const enterClass = newIdSet.has(id) ? " played-new" : "";
        const who = escapeHtml(play.uid === state.uid ? "你" : nameOf(play.uid));
        const cards = (Array.isArray(play.cards) ? play.cards : [play]).map((x) => normalizeCard(x)).filter(Boolean);
        if (!cards.length) {
          return `<div class="small muted">第 ${offset + idx + 1} 手：${who}（数据不可用）</div>`;
        }
        if (coreOn) {
          return `
            <div class="played-turn${enterClass}">
              <div class="small">${who}</div>
              <div class="played-turn-cards">
                ${cards.map((card) => {
                  const src = cardImageUrl(card);
                  const alt = escapeHtml(cardPrettyName(card));
                  return `
                    <div class="played-chip">
                      <img class="played-card" src="${src}" alt="${alt}" />
                    </div>
                  `;
                }).join("")}
              </div>
            </div>
          `;
        }
        return `
          <div class="played-turn${enterClass}">
            <div class="small">${offset + idx + 1}. ${who}</div>
            <div class="played-turn-cards">
              ${cards.map((card) => {
                const src = cardImageUrl(card);
                const alt = escapeHtml(cardPrettyName(card));
                return `
                  <div class="played-chip">
                    <img class="played-card" src="${src}" alt="${alt}" />
                    <div class="played-cap">${alt}</div>
                  </div>
                `;
              }).join("")}
            </div>
          </div>
        `;
      }).join("")}`);
    }

    function renderTeamCall() {
      const room = state.room;
      if (!room || room.status !== "playing" || roomMode(room) !== MODE_POKER_B4 || !room.game?.teamCall) {
        teamCallWrap.style.display = "none";
        teamCallOptions.innerHTML = "";
        teamCallHint.textContent = "";
        return;
      }

      const mySeat = getMySeat(room);
      const call = room.game.teamCall;
      if (call.resolved || mySeat !== call.ownerSeat) {
        teamCallWrap.style.display = "none";
        teamCallOptions.innerHTML = "";
        teamCallHint.textContent = "";
        return;
      }

      teamCallWrap.style.display = "block";
      teamCallHint.textContent = "你持有黑桃A，请选择一张 K 及以下（4~K）的具体牌作为队友牌。";
      const optionCards = (call.options || []).map((id) => normalizeCard({ id })).filter(Boolean);
      teamCallOptions.innerHTML = optionCards.map((card) => {
        const title = escapeHtml(cardPrettyName(card));
        const src = cardImageUrl(card);
        return `<button class="card-btn" data-call-card="${escapeHtml(card.id)}" title="${title}"><img class="card-img" src="${src}" alt="${title}" /></button>`;
      }).join("");
      teamCallOptions.querySelectorAll("button[data-call-card]").forEach((btn) => {
        btn.addEventListener("click", async () => {
          await chooseTeamCard(btn.dataset.callCard || "");
        });
      });
    }

    function renderRulesInfo() {
      const mode = state.room ? roomMode(state.room) : (gameModeSelect.value || MODE_CLASSIC);
      rulesInfo.textContent = modeRulesText(mode);
    }

    function syncUnifiedWindowPanels(useUnified) {
      if (!gridRoot || !unifiedWindowHost || !gamePanelEl || !playedPanelEl) return;
      if (useUnified) {
        const centerDock = document.getElementById("tableCenterDock");
        const seatPlayDock = document.getElementById("seatPlayDock");
        // Wait until renderSeats creates target docks; never move to hidden fallback.
        if (!centerDock) return;
        if (playedPanelEl.parentElement !== centerDock) centerDock.appendChild(playedPanelEl);
        if (seatPlayDock) {
          if (gamePanelEl.parentElement !== seatPlayDock) seatPlayDock.appendChild(gamePanelEl);
        } else if (gamePanelEl.parentElement !== centerDock) {
          centerDock.appendChild(gamePanelEl);
        }
        return;
      }

      const anchor = rulesPanelEl && rulesPanelEl.parentElement === gridRoot ? rulesPanelEl : null;
      const bothInGrid = gamePanelEl.parentElement === gridRoot && playedPanelEl.parentElement === gridRoot;
      if (bothInGrid) {
        const gameBeforePlayed = !!(gamePanelEl.compareDocumentPosition(playedPanelEl) & Node.DOCUMENT_POSITION_FOLLOWING);
        const playedBeforeAnchor = !anchor || !!(playedPanelEl.compareDocumentPosition(anchor) & Node.DOCUMENT_POSITION_FOLLOWING);
        if (gameBeforePlayed && playedBeforeAnchor) return;
      }

      if (gamePanelEl.parentElement) gamePanelEl.parentElement.removeChild(gamePanelEl);
      if (playedPanelEl.parentElement) playedPanelEl.parentElement.removeChild(playedPanelEl);
      if (anchor) {
        gridRoot.insertBefore(gamePanelEl, anchor);
        gridRoot.insertBefore(playedPanelEl, anchor);
      } else {
        gridRoot.appendChild(gamePanelEl);
        gridRoot.appendChild(playedPanelEl);
      }
    }

    function applyLayoutModes() {
      const status = state.room?.status || "";
      const inMatch = status === "bidding" || status === "playing" || status === "finished";
      const useUnified = !!state.landscapeUi && !!state.tableCoreUi && inMatch;
      syncUnifiedWindowPanels(useUnified);
      document.body.classList.toggle("landscape-ui", !!state.landscapeUi);
      document.body.classList.toggle("table-core-ui", !!state.tableCoreUi);
      document.body.classList.toggle("in-match", inMatch);
      if (toggleLandscapeBtn) {
        toggleLandscapeBtn.classList.toggle("active", !!state.landscapeUi);
        toggleLandscapeBtn.textContent = state.landscapeUi ? "横屏布局：开" : "横屏布局：关";
      }
      if (toggleCoreUiBtn) {
        toggleCoreUiBtn.classList.toggle("active", !!state.tableCoreUi);
        toggleCoreUiBtn.textContent = state.tableCoreUi ? "核心界面：开" : "核心界面：关";
      }
      if (toggleCoreUiFloatBtn) {
        toggleCoreUiFloatBtn.textContent = state.tableCoreUi ? "显示界面" : "隐藏界面";
      }
    }

    function render() {
      applyLayoutModes();
      renderRoomInfo();
      renderSeats();
      const status = state.room?.status || "";
      const inMatch = status === "bidding" || status === "playing" || status === "finished";
      const useUnified = !!state.landscapeUi && !!state.tableCoreUi && inMatch;
      syncUnifiedWindowPanels(useUnified);
      renderGame();
      renderHand();
      renderPlayedWindow();
      renderTeamCall();
      renderRulesInfo();
      renderLobbyMessages();
      renderButtons();
      maybeShowVictoryCelebration();
    }

    let authInitStarted = false;
    function unlockGateAndStart() {
      document.body.classList.remove("locked");
      gateOverlay.style.display = "none";
      gateMsg.textContent = "";
      if (!authInitStarted) {
        authInitStarted = true;
        initAuth();
      }
    }

    function lockGate() {
      document.body.classList.add("locked");
      gateOverlay.style.display = "flex";
      gateInput.value = "";
      gateMsg.textContent = "";
      setTimeout(() => gateInput.focus(), 0);
    }

    function submitGate() {
      const code = gateInput.value.trim();
      if (code !== GATE_CODE) {
        gateMsg.textContent = "访问码错误，请重试。";
        return;
      }
      unlockGateAndStart();
    }

    async function tryRestoreRoomAfterAuth() {
      if (state.roomId) return true;
      const roomFromUrl = new URL(location.href).searchParams.get("room");
      if (roomFromUrl) {
        const okByUrl = await joinRoom(roomFromUrl, { silent: false });
        if (okByUrl) return true;
      }

      const saved = readLastRoom();
      if (!saved) return false;
      const ok = await joinRoom(saved, { silent: true });
      if (!ok) persistLastRoom("");
      if (ok) showMsg(`已恢复到上次房间 ${saved}`);
      return ok;
    }

    async function handleNetworkOnline() {
      state.networkOnline = true;
      showMsg("网络已恢复，正在重连同步...");
      log("网络已恢复，尝试重连同步");
      render();
      if (!state.uid) return;
      if (state.roomId) {
        attachRoomListeners();
        await refreshRoomAndHand();
      } else {
        await tryRestoreRoomAfterAuth();
      }
    }

    function handleNetworkOffline() {
      state.networkOnline = false;
      showMsg("网络已断开，等待自动重连", true);
      log("网络已断开，等待自动重连");
      render();
    }

    async function initAuth() {
      if (!supabase) {
        authStatus.textContent = "未配置 Supabase";
        showMsg("请先在 index.html 填写 SUPABASE_CONFIG（url + publishableKey）", true);
        return;
      }

      authStatus.textContent = "匿名登录中...";

      const { data: listener } = supabase.auth.onAuthStateChange((_event, session) => {
        if (session?.user) {
          state.uid = session.user.id;
          authStatus.textContent = `匿名登录：${state.uid.slice(0, 8)}...`;
          attachLobbyListeners();
          render();
        }
      });

      state.authUnsub = () => listener.subscription.unsubscribe();

      const { data: sessData, error: sessErr } = await supabase.auth.getSession();
      if (sessErr) {
        authStatus.textContent = `获取会话失败：${friendlyErr(sessErr)}`;
        showMsg(`登录失败：${friendlyErr(sessErr)}`, true);
        return;
      }

      if (!sessData.session) {
        const { data, error } = await supabase.auth.signInAnonymously();
        if (error) {
          authStatus.textContent = `匿名登录失败：${friendlyErr(error)}`;
          showMsg(`匿名登录失败：${friendlyErr(error)}`, true);
          return;
        }
        state.uid = data.user?.id || "";
      } else {
        state.uid = sessData.session.user.id;
      }

      authStatus.textContent = `匿名登录：${state.uid.slice(0, 8)}...`;
      attachLobbyListeners();
      await tryRestoreRoomAfterAuth();
      try {
        await runHousekeeping(true);
      } catch (err) {
        log(`系统清理任务失败：${friendlyErr(err)}`);
      }
      if (state.housekeepingTimer) clearInterval(state.housekeepingTimer);
      state.housekeepingTimer = setInterval(async () => {
        try {
          await runHousekeeping(false);
        } catch (err) {
          log(`系统清理任务失败：${friendlyErr(err)}`);
        }
      }, HOUSEKEEP_INTERVAL_MS);
      if (state.roomId) {
        const saved = restoreSelectedCards();
        if (saved.length && !state.selectedCardIds.length) {
          state.selectedCardIds = saved;
          persistSelectedCards();
          render();
        }
      }
    }

    saveNickBtn.addEventListener("click", async () => {
      const nextNick = nicknameInput.value.trim().slice(0, 12);
      if (!nextNick) return;
      state.nick = nextNick;
      localStorage.setItem("ddz_nick", nextNick);

      if (state.roomId && state.uid) {
        await mutateRoom(state.roomId, (room) => {
          ensureRoomStateShape(room);
          if (!room.state.members[state.uid]) return false;
          room.state.members[state.uid].nick = nextNick;
        });
      }
      log(`昵称已更新为 ${nextNick}`);
    });

    gameModeSelect.addEventListener("change", () => {
      if (!state.room) renderRulesInfo();
    });

    createRoomBtn.addEventListener("click", async () => {
      await createRoom();
    });

    joinRoomBtn.addEventListener("click", async () => {
      await joinRoom(roomCodeInput.value);
    });

    leaveRoomBtn.addEventListener("click", async () => {
      await leaveRoom();
    });

    copyLinkBtn.addEventListener("click", async () => {
      if (!state.roomId) return;
      const link = `${location.origin}${location.pathname}?room=${state.roomId}`;
      await navigator.clipboard.writeText(link);
      showMsg("邀请链接已复制");
    });

    startBtn.addEventListener("click", async () => {
      await startGame();
    });

    undoBtn.addEventListener("click", async () => {
      await undoLastPlay();
    });

    restartBtn.addEventListener("click", async () => {
      await restartGame();
    });

    closeRoomBtn.addEventListener("click", async () => {
      await closeRoomByHost();
    });

    hostTakeoverBtn.addEventListener("click", async () => {
      await takeHost();
    });

    bidWrap.querySelectorAll("button[data-bid]").forEach((btn) => {
      btn.addEventListener("click", async () => {
        await bid(Number(btn.dataset.bid));
      });
    });

    playSelectedBtn.addEventListener("click", async () => {
      await playSelected();
    });
    clearSelectionBtn.addEventListener("click", () => {
      if (!state.selectedCardIds.length) return;
      state.selectedCardIds = [];
      persistSelectedCards();
      renderHand();
      renderButtons();
    });

    passBtn.addEventListener("click", async () => {
      await pass();
    });

    sendLobbyMessageBtn.addEventListener("click", async () => {
      await sendLobbyMessage();
    });

    toggleLobbyMessagesBtn.addEventListener("click", async () => {
      await toggleLobbyMessages();
    });
    toggleLandscapeBtn.addEventListener("click", () => {
      state.landscapeUi = !state.landscapeUi;
      localStorage.setItem(LAYOUT_LANDSCAPE_KEY, state.landscapeUi ? "1" : "0");
      render();
    });
    const toggleCoreUi = () => {
      state.tableCoreUi = !state.tableCoreUi;
      localStorage.setItem(TABLE_CORE_UI_KEY, state.tableCoreUi ? "1" : "0");
      render();
    };
    if (toggleCoreUiBtn) toggleCoreUiBtn.addEventListener("click", toggleCoreUi);
    if (toggleCoreUiFloatBtn) toggleCoreUiFloatBtn.addEventListener("click", toggleCoreUi);
    handScrollBar.addEventListener("input", () => {
      handCards.scrollLeft = Number(handScrollBar.value || 0);
    });
    handCards.addEventListener("scroll", () => {
      scheduleUpdateHandScrollBar();
    }, { passive: true });
    window.addEventListener("resize", () => {
      scheduleUpdateHandScrollBar();
    });

    lobbyMessageInput.addEventListener("keydown", async (evt) => {
      if (evt.key === "Enter") await sendLobbyMessage();
    });

    gateBtn.addEventListener("click", submitGate);
    gateInput.addEventListener("keydown", (evt) => {
      if (evt.key === "Enter") submitGate();
    });
    playedNow.addEventListener("scroll", () => {
      scheduleSavePlayedWindowPos();
    });
    window.addEventListener("online", () => {
      handleNetworkOnline().catch((err) => {
        log(`网络恢复后同步失败：${friendlyErr(err)}`);
      });
    });
    window.addEventListener("offline", () => {
      handleNetworkOffline();
    });
    victoryCloseBtn.addEventListener("click", () => {
      hideVictoryCelebration();
    });

    window.addEventListener("beforeunload", () => {
      if (state.pollTimer) clearInterval(state.pollTimer);
      if (state.lobbyPollTimer) clearInterval(state.lobbyPollTimer);
      if (state.housekeepingTimer) clearInterval(state.housekeepingTimer);
      for (const fn of state.roomUnsubs) fn();
      for (const fn of state.lobbyUnsubs) fn();
      if (state.authUnsub) state.authUnsub();
      savePlayedWindowPos();
      if (state.playedScrollSaveTimer) clearTimeout(state.playedScrollSaveTimer);
      clearVictoryTimers();
    });

    window.__ddzState = state;
    render();
    lockGate();
  </script>
</body>
</html>
