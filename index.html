<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>斗地主原型（Supabase）</title>
  <style>
    :root {
      --bg: #f1ecdf;
      --card: rgba(255, 253, 247, 0.88);
      --ink: #211d17;
      --accent: #0e6c43;
      --warn: #96421a;
      --line: #d4cab6;
      --gold: #d6ab42;
      --surface: #f8f3e9;
      --shadow: 0 10px 28px rgba(45, 36, 22, 0.13);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Noto Sans SC", "PingFang SC", "Microsoft YaHei", sans-serif;
      background:
        radial-gradient(circle at 8% -2%, #fff6da 0, transparent 34%),
        radial-gradient(circle at 94% 5%, #fcead7 0, transparent 28%),
        linear-gradient(160deg, #f6f2e8 0%, #efe7d8 100%);
      color: var(--ink);
    }
    body.locked {
      overflow: hidden;
    }
    .gate-overlay {
      position: fixed;
      inset: 0;
      z-index: 1000;
      display: none;
      align-items: center;
      justify-content: center;
      background:
        radial-gradient(circle at 20% 15%, rgba(255, 247, 220, .72) 0, transparent 42%),
        linear-gradient(165deg, rgba(43, 37, 29, .76), rgba(25, 21, 16, .92));
      backdrop-filter: blur(4px);
    }
    .gate-card {
      width: min(92vw, 420px);
      background: #fffdf6;
      border: 1px solid #d7c9aa;
      border-radius: 14px;
      box-shadow: 0 16px 36px rgba(15, 10, 6, .4);
      padding: 16px;
      display: grid;
      gap: 10px;
    }
    .gate-title {
      margin: 0;
      font-size: 18px;
    }
    .gate-msg {
      font-size: 12px;
      color: #8f2b1f;
      min-height: 18px;
    }
    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: 16px;
      display: grid;
      gap: 12px;
    }
    .panel {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(5px);
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
    }
    h1 { margin: 0; font-size: 20px; }
    h2 { margin: 0 0 8px; font-size: 16px; }
    input, button, select {
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 14px;
      background: #fff;
      color: var(--ink);
    }
    button {
      cursor: pointer;
      background: #f7f3ea;
      transition: transform .15s ease, box-shadow .15s ease, background .15s ease;
    }
    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 5px 14px rgba(38, 30, 18, .16);
      background: #fff9ee;
    }
    button.primary { border-color: #115f3b; background: var(--accent); color: #fff; }
    button.warn { border-color: #82370f; background: var(--warn); color: #fff; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 12px;
    }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .small { font-size: 12px; color: #5b554c; }
    .muted { color: #6f675d; }
    .seats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap: 8px;
    }
    .seat {
      border: 1px dashed #ccbfa8;
      border-radius: 12px;
      padding: 10px;
      min-height: 108px;
      background: linear-gradient(180deg, #fffdfa 0%, #faf5ec 100%);
    }
    .seat.you {
      border-color: #1a7a4c;
      background: linear-gradient(180deg, #eefbf3 0%, #e4f3ea 100%);
    }
    .pill {
      display: inline-block;
      border: 1px solid #cdbf9f;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 12px;
      margin-right: 6px;
      background: #fff9ec;
    }
    #handCards {
      display: flex;
      flex-wrap: nowrap;
      min-height: 112px;
      align-items: flex-end;
      padding: 8px 8px 10px;
      overflow-x: auto;
      overflow-y: visible;
    }
    .card-btn {
      border: 0;
      border-radius: 12px;
      background: transparent;
      min-width: auto;
      padding: 0;
      box-shadow: none;
      margin-left: -38px;
      position: relative;
      z-index: 1;
      flex: 0 0 auto;
    }
    #handCards .card-btn:first-child { margin-left: 0; }
    .card-img {
      width: 72px;
      height: 104px;
      display: block;
      border-radius: 12px;
      box-shadow: 0 6px 14px rgba(44, 33, 18, .2);
      transition: transform .16s ease, box-shadow .16s ease, filter .16s ease;
    }
    .card-btn:hover:not(:disabled) .card-img {
      transform: translateY(-6px);
      box-shadow: 0 12px 20px rgba(42, 33, 19, .24);
      filter: saturate(1.08);
    }
    .card-btn:hover:not(:disabled) { z-index: 20; }
    .card-btn:disabled .card-img {
      filter: grayscale(.22) saturate(.74) brightness(.93);
      opacity: .8;
      box-shadow: 0 4px 9px rgba(44, 33, 18, .14);
    }
    .card-btn.selected .card-img {
      transform: translateY(-8px);
      box-shadow: 0 13px 20px rgba(42, 33, 19, .24);
      outline: 2px solid #c49028;
    }
    .card-btn.selected { z-index: 30; }
    .red { color: #b61f1f; }
    .log {
      max-height: 180px;
      overflow: auto;
      margin: 0;
      padding-left: 18px;
    }
    .log li { margin-bottom: 4px; }
    .played-zone {
      display: grid;
      gap: 10px;
    }
    .played-row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      min-height: 70px;
      padding: 8px;
      border: 1px solid #dbcdb5;
      border-radius: 10px;
      background: linear-gradient(180deg, #fffdf8 0%, #f8f1e3 100%);
    }
    .rules-box {
      border: 1px solid #decfb5;
      border-radius: 10px;
      background: linear-gradient(180deg, #fffdf8 0%, #f8f1e3 100%);
      padding: 10px;
      line-height: 1.55;
      font-size: 13px;
      color: #4f4436;
      white-space: pre-wrap;
    }
    .played-chip {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      min-width: 68px;
    }
    .played-card {
      width: 54px;
      height: 78px;
      border-radius: 9px;
      box-shadow: 0 4px 10px rgba(45, 34, 19, .2);
      display: block;
    }
    .played-cap {
      font-size: 11px;
      color: #5f5547;
      max-width: 78px;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      text-align: center;
    }
    .ok { color: #126842; }
    .err { color: #9e3316; }
    .hero-note {
      margin-top: 6px;
      padding: 8px 10px;
      border-radius: 10px;
      background: linear-gradient(90deg, #fff7e4 0%, #f8efd9 100%);
      border: 1px solid #e2d2b3;
      color: #6a5731;
      font-size: 12px;
    }
    .seat.turning {
      border-color: #d0972f;
      box-shadow: 0 0 0 2px rgba(213, 158, 46, .16) inset;
    }
    @media (max-width: 680px) {
      h1 { font-size: 17px; }
      .wrap { padding: 12px; }
      .panel { padding: 12px; }
      .card-img { width: 62px; height: 90px; }
      .card-btn { margin-left: -30px; }
      .played-card { width: 46px; height: 66px; }
    }
  </style>
</head>
<body>
  <div id="gateOverlay" class="gate-overlay">
    <div class="gate-card">
      <h2 class="gate-title">访问验证</h2>
      <div class="small">请输入访问码后进入游戏。</div>
      <input id="gateInput" type="password" inputmode="numeric" placeholder="输入访问码" maxlength="12" />
      <button id="gateBtn" class="primary">进入</button>
      <div id="gateMsg" class="gate-msg"></div>
    </div>
  </div>

  <div class="wrap">
    <div class="panel">
      <div class="row" style="justify-content: space-between;">
        <h1>斗地主原型（Supabase，非 Google 依赖）</h1>
        <div id="authStatus" class="small">登录中...</div>
      </div>
      <div class="hero-note">房间上限 9 人，支持单人验证/2-4 人对局。当前重点是联机流程验证与规则体验。</div>
    </div>

    <div class="panel">
      <h2>大厅</h2>
      <div class="row">
        <label>昵称</label>
        <input id="nicknameInput" maxlength="12" placeholder="输入昵称" />
        <button id="saveNickBtn">保存昵称</button>
        <label>模式</label>
        <select id="gameModeSelect">
          <option value="classic_simple">经典原型</option>
          <option value="solo_validate">单人验证</option>
          <option value="poker_a_2">双人扑克A</option>
          <option value="poker_a_4">4人扑克A</option>
        </select>
      </div>
      <div class="row" style="margin-top: 8px;">
        <button id="createRoomBtn" class="primary">创建房间</button>
        <input id="roomCodeInput" maxlength="8" placeholder="输入房间码" class="mono" />
        <button id="joinRoomBtn">加入房间</button>
      </div>
      <div class="row" style="margin-top: 8px;">
        <span>当前房间：</span>
        <span id="roomCodeLabel" class="mono">-</span>
        <button id="copyLinkBtn">复制邀请链接</button>
        <button id="leaveRoomBtn" class="warn">离开房间</button>
      </div>
      <div id="lobbyMsg" class="small muted" style="margin-top: 8px;"></div>
    </div>

    <div class="grid">
      <div class="panel">
        <h2>房间与座位</h2>
        <div id="roomInfo" class="small">尚未加入房间</div>
        <div class="seats" id="seatsWrap" style="margin-top: 8px;"></div>
        <div class="row" style="margin-top: 8px;">
          <button id="toggleReadyBtn">准备</button>
          <button id="startBtn" class="primary">开始游戏</button>
          <button id="undoBtn">悔牌</button>
          <button id="restartBtn" class="warn">重开</button>
          <button id="hostTakeoverBtn">接管房主</button>
        </div>
      </div>

      <div class="panel">
        <h2>游戏</h2>
        <div id="gameInfo" class="small">等待开局</div>
        <div class="row" id="bidWrap" style="margin-top: 8px; display: none;">
          <span>叫分：</span>
          <button data-bid="0">不叫</button>
          <button data-bid="1">1分</button>
          <button data-bid="2">2分</button>
          <button data-bid="3">3分</button>
        </div>
        <div class="row" id="playActions" style="margin-top: 8px; display: none;">
          <button id="playSelectedBtn" class="primary">出所选牌</button>
          <button id="passBtn">过牌</button>
        </div>
        <div style="margin-top: 8px;">
          <div class="small">你的手牌</div>
          <div id="handCards"></div>
        </div>
      </div>

      <div class="panel">
        <h2>出牌窗口</h2>
        <div class="played-zone">
          <div class="small">上一个玩家出的牌</div>
          <div id="playedNow" class="played-row"></div>
        </div>
      </div>

      <div class="panel">
        <h2>规则说明</h2>
        <div id="rulesInfo" class="rules-box small"></div>
      </div>
    </div>

    <div class="panel">
      <h2>事件日志</h2>
      <ul id="eventLog" class="log small"></ul>
    </div>
  </div>

  <script type="module">
    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

    // 替换为 Supabase 项目配置。
    // 也可在页面外注入: window.SUPABASE_CONFIG = { url, publishableKey }
    const supabaseConfig = window.SUPABASE_CONFIG || {
      url: "https://eavgvsmklualdetrrznf.supabase.co",
      publishableKey: "sb_publishable_hl2JO9TOrGCldYEIitM0qA_7o6XNek_"
    };

    const TABLE_MIN_PLAYERS = 2;
    const TABLE_MAX_PLAYERS = 4;
    const TABLE_SEAT_COUNT = 4;
    const TABLE_SEAT_MIN = 1;
    const MODE_CLASSIC = "classic_simple";
    const MODE_SOLO_VALIDATE = "solo_validate";
    const MODE_POKER_A2 = "poker_a_2";
    const MODE_POKER_A4 = "poker_a_4";
    const GATE_CODE = "888888";

    const state = {
      uid: "",
      nick: localStorage.getItem("ddz_nick") || `玩家${Math.floor(Math.random() * 9000 + 1000)}`,
      roomId: "",
      room: null,
      hand: {},
      selectedCardIds: [],
      logs: [],
      roomUnsubs: [],
      authUnsub: null,
      pollTimer: null,
      realtimeReady: false
    };

    const authStatus = document.getElementById("authStatus");
    const gateOverlay = document.getElementById("gateOverlay");
    const gateInput = document.getElementById("gateInput");
    const gateBtn = document.getElementById("gateBtn");
    const gateMsg = document.getElementById("gateMsg");
    const nicknameInput = document.getElementById("nicknameInput");
    const saveNickBtn = document.getElementById("saveNickBtn");
    const gameModeSelect = document.getElementById("gameModeSelect");
    const createRoomBtn = document.getElementById("createRoomBtn");
    const roomCodeInput = document.getElementById("roomCodeInput");
    const joinRoomBtn = document.getElementById("joinRoomBtn");
    const roomCodeLabel = document.getElementById("roomCodeLabel");
    const copyLinkBtn = document.getElementById("copyLinkBtn");
    const leaveRoomBtn = document.getElementById("leaveRoomBtn");
    const lobbyMsg = document.getElementById("lobbyMsg");
    const roomInfo = document.getElementById("roomInfo");
    const seatsWrap = document.getElementById("seatsWrap");
    const toggleReadyBtn = document.getElementById("toggleReadyBtn");
    const startBtn = document.getElementById("startBtn");
    const undoBtn = document.getElementById("undoBtn");
    const restartBtn = document.getElementById("restartBtn");
    const hostTakeoverBtn = document.getElementById("hostTakeoverBtn");
    const gameInfo = document.getElementById("gameInfo");
    const bidWrap = document.getElementById("bidWrap");
    const playActions = document.getElementById("playActions");
    const playSelectedBtn = document.getElementById("playSelectedBtn");
    const passBtn = document.getElementById("passBtn");
    const handCards = document.getElementById("handCards");
    const eventLog = document.getElementById("eventLog");
    const playedNow = document.getElementById("playedNow");
    const rulesInfo = document.getElementById("rulesInfo");

    nicknameInput.value = state.nick;
    gameModeSelect.value = MODE_CLASSIC;

    function log(msg) {
      const now = new Date().toLocaleTimeString();
      state.logs.unshift(`[${now}] ${msg}`);
      state.logs = state.logs.slice(0, 60);
      eventLog.innerHTML = state.logs.map((x) => `<li>${escapeHtml(x)}</li>`).join("");
    }

    function showMsg(msg, isErr = false) {
      lobbyMsg.className = `small ${isErr ? "err" : "ok"}`;
      lobbyMsg.textContent = msg;
    }

    function escapeHtml(str) {
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function clone(obj) {
      if (typeof structuredClone === "function") return structuredClone(obj);
      return JSON.parse(JSON.stringify(obj));
    }

    function randRoomCode() {
      const chars = "ABCDEFGHJKMNPQRSTUVWXYZ23456789";
      let code = "";
      for (let i = 0; i < 6; i += 1) code += chars[Math.floor(Math.random() * chars.length)];
      return code;
    }

    function friendlyErr(err) {
      if (!err) return "未知错误";
      const code = String(err.code || "");
      const msg = String(err.message || "");
      const raw = `${code} ${msg}`;
      if (raw.includes("Anonymous") || raw.includes("anonymous")) return "匿名登录未开启（Supabase Auth -> Anonymous Sign-Ins）";
      if (raw.includes("Invalid API key") || raw.includes("JWT") || raw.includes("apikey")) return "Supabase publishable key 无效";
      if (raw.includes("NetworkError") || raw.includes("Failed to fetch")) return "网络异常，无法连接 Supabase";
      if (raw.includes("permission") || raw.includes("policy")) return "数据库权限不足（请检查 RLS 策略）";
      if (raw.includes("23505")) return "房间码冲突，请重试";
      return code || msg || "未知错误";
    }

    const supabaseKey = supabaseConfig.publishableKey || supabaseConfig.anonKey || "REPLACE_ME";

    function isConfigReady() {
      return !!supabaseConfig.url
        && !!supabaseKey
        && supabaseConfig.url !== "REPLACE_ME"
        && supabaseKey !== "REPLACE_ME";
    }

    const supabase = isConfigReady()
      ? createClient(supabaseConfig.url, supabaseKey, {
        auth: { persistSession: true, autoRefreshToken: true }
      })
      : null;

    function buildSeatIndexes(seatCount = TABLE_SEAT_COUNT) {
      const n = Math.max(TABLE_SEAT_MIN, Math.min(TABLE_SEAT_COUNT, Number(seatCount) || TABLE_SEAT_COUNT));
      return Array.from({ length: n }, (_, i) => i);
    }

    function activeSeatsFrom(seats, seatCount = TABLE_SEAT_COUNT) {
      return buildSeatIndexes(seatCount).filter((seat) => !!seats?.[String(seat)]);
    }

    function getBottomCardCount(playerCount) {
      if (playerCount === 3) return 3;
      if (playerCount === 2 || playerCount === 4) return 2;
      return 2;
    }

    function modeLabel(mode) {
      if (mode === MODE_POKER_A4) return "4人扑克A";
      if (mode === MODE_POKER_A2) return "双人扑克A";
      if (mode === MODE_SOLO_VALIDATE) return "单人验证";
      return "经典原型";
    }

    function roomMode(roomLike) {
      return roomLike?.state?.gameMode || roomLike?.gameMode || MODE_CLASSIC;
    }

    function modeRulesText(mode) {
      if (mode === MODE_SOLO_VALIDATE) {
        return [
          "单人验证模式",
          "- 开局人数：1人",
          "- 发牌：54张全部发给你（无底牌）",
          "- 目标：本地快速验证出牌牌型和视觉，不需要等待他人",
          "- 出牌：选择若干牌后点击“出所选牌”"
        ].join("\n");
      }
      if (mode === MODE_POKER_A2) {
        return [
          "双人扑克A",
          "- 开局人数：2人",
          "- 先从54张中随机抽取10张，不参与本局",
          "- 剩余44张平均发给双方（各22张）",
          "- 牌型与比较规则与4人扑克A一致",
          "- 先出完手牌获胜"
        ].join("\n");
      }
      if (mode === MODE_POKER_A4) {
        return [
          "4人扑克A",
          "- 开局人数：4人",
          "- 允许牌型：单张、对子、三炸、四炸、顺子(>=3)、连对(>=3对)",
          "- 点数顺序：4<5<6<7<8<9<10<J<Q<K<A<2<3<小王<大王",
          "- 炸弹优先：双王>四炸>三炸；炸弹可压非炸弹",
          "- 捕获：44可捕获三炸，444可捕获四炸，被捕获牌并入自己手牌",
          "- 先出完手牌获胜"
        ].join("\n");
      }
      return [
        "经典原型",
        "- 开局人数：2-4人",
        "- 当前只验证单张比较流程",
        "- 出牌：每次选择1张后点击“出所选牌”"
      ].join("\n");
    }

    function ensureRoomStateShape(work) {
      work.state = work.state || {};
      work.state.gameMode = work.state.gameMode || MODE_CLASSIC;
      work.state.members = work.state.members || {};
      work.state.seatCount = Math.max(
        TABLE_SEAT_MIN,
        Math.min(TABLE_SEAT_COUNT, Number(work.state.seatCount) || TABLE_SEAT_COUNT)
      );
      if (work.state.gameMode === MODE_SOLO_VALIDATE) {
        work.state.seatCount = 1;
      } else if (work.state.gameMode === MODE_POKER_A2) {
        work.state.seatCount = 2;
      } else if (work.state.gameMode === MODE_POKER_A4) {
        work.state.seatCount = 4;
      }
      work.state.seats = work.state.seats || {};
      for (const seat of buildSeatIndexes(work.state.seatCount)) {
        const key = String(seat);
        if (!(key in work.state.seats)) work.state.seats[key] = null;
      }
      work.state.ready = work.state.ready || {};
      work.state.publicCounts = work.state.publicCounts || {};
      if (typeof work.max_members !== "number") work.max_members = 9;
    }

    function mapRoomRow(row) {
      if (!row) return null;
      const s = clone(row.state || {});
      return {
        id: row.room_id,
        hostUid: row.host_uid,
        maxMembers: row.max_members || 9,
        status: row.status,
        gameMode: s.gameMode || MODE_CLASSIC,
        seatCount: s.seatCount || TABLE_SEAT_COUNT,
        members: s.members || {},
        seats: s.seats || {},
        ready: s.ready || {},
        publicCounts: s.publicCounts || {},
        game: s.game || null,
        revision: row.revision
      };
    }

    function getMySeat(room) {
      if (!room || !room.seats || !state.uid) return null;
      for (const [seat, uid] of Object.entries(room.seats)) {
        if (uid === state.uid) return Number(seat);
      }
      return null;
    }

    function nextSeat(activeSeats, cur) {
      if (!activeSeats.length) return cur;
      const idx = activeSeats.indexOf(cur);
      if (idx === -1) return activeSeats[0];
      return activeSeats[(idx + 1) % activeSeats.length];
    }

    const SUIT_SYMBOL = { S: "♠", H: "♥", C: "♣", D: "♦" };
    const cardImageCache = new Map();

    function cardPrettyName(card) {
      if (!card) return "-";
      if (card.id === "SJ") return "小王";
      if (card.id === "BJ") return "大王";
      return `${card.rank}${SUIT_SYMBOL[card.suit] || ""}`;
    }

    function cardSvg(card) {
      const isRed = !!card.red;
      const color = isRed ? "#b51221" : "#151515";
      const border = isRed ? "#d79aa0" : "#b4b9bf";
      const rank = card.id === "SJ" || card.id === "BJ" ? "JOKER" : card.rank;
      const symbol = card.id === "SJ" || card.id === "BJ" ? "★" : (SUIT_SYMBOL[card.suit] || "");
      const center = card.id === "SJ" ? "JOKER" : card.id === "BJ" ? "JOKER+" : symbol;

      return `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 180 252">
  <defs>
    <linearGradient id="g" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0%" stop-color="#ffffff"/>
      <stop offset="100%" stop-color="#f6f0e5"/>
    </linearGradient>
  </defs>
  <rect x="6" y="6" width="168" height="240" rx="18" fill="url(#g)" stroke="${border}" stroke-width="2"/>
  <text x="20" y="34" font-size="24" font-family="Georgia, serif" font-weight="700" fill="${color}">${rank}</text>
  <text x="22" y="58" font-size="24" font-family="Georgia, serif" fill="${color}">${symbol}</text>
  <text x="90" y="142" text-anchor="middle" font-size="${card.id === "SJ" || card.id === "BJ" ? 26 : 62}" font-family="Georgia, serif" font-weight="700" fill="${color}">${center}</text>
  <g transform="translate(180,252) rotate(180)">
    <text x="20" y="34" font-size="24" font-family="Georgia, serif" font-weight="700" fill="${color}">${rank}</text>
    <text x="22" y="58" font-size="24" font-family="Georgia, serif" fill="${color}">${symbol}</text>
  </g>
</svg>`.trim();
    }

    function cardImageUrl(card) {
      if (cardImageCache.has(card.id)) return cardImageCache.get(card.id);
      const svg = cardSvg(card);
      const url = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg)}`;
      cardImageCache.set(card.id, url);
      return url;
    }

    function normalizeCard(record) {
      if (!record) return null;
      if (record.card && record.card.id) return record.card;
      const id = record.cardId || record.id;
      if (!id) return null;
      if (id === "SJ") return { id: "SJ", rank: "SJ", suit: "", power: 18, label: "小王", red: false };
      if (id === "BJ") return { id: "BJ", rank: "BJ", suit: "", power: 20, label: "大王", red: true };
      const suit = id.slice(-1);
      const rank = id.slice(0, -1);
      const rankPower = {
        "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8,
        "9": 9, "10": 10, J: 11, Q: 12, K: 13, A: 14, "2": 16
      };
      return {
        id,
        rank,
        suit,
        power: rankPower[rank] || 0,
        label: `${rank}${SUIT_SYMBOL[suit] || ""}`,
        red: suit === "H" || suit === "D"
      };
    }

    const POKER_A_ORDER = ["4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A", "2", "3", "SJ", "BJ"];
    const POKER_A_STRAIGHT_ORDER = ["4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];
    const POKER_A_VALUE = Object.fromEntries(POKER_A_ORDER.map((r, i) => [r, i + 1]));
    const POKER_A_STRAIGHT_VALUE = Object.fromEntries(POKER_A_STRAIGHT_ORDER.map((r, i) => [r, i + 1]));

    function getCardValue(card, mode) {
      if (
        mode === MODE_CLASSIC
        || mode === MODE_SOLO_VALIDATE
        || mode === MODE_POKER_A2
        || mode === MODE_POKER_A4
      ) return POKER_A_VALUE[card.rank] || 0;
      return card.power || 0;
    }

    function sortedCardsByMode(cards, mode) {
      return [...cards].sort((a, b) => {
        const d = getCardValue(a, mode) - getCardValue(b, mode);
        if (d) return d;
        return a.id.localeCompare(b.id);
      });
    }

    function isBombType(type) {
      return type === "joker_bomb" || type === "quad_bomb" || type === "triple_bomb";
    }

    function bombLevel(type) {
      if (type === "joker_bomb") return 3;
      if (type === "quad_bomb") return 2;
      if (type === "triple_bomb") return 1;
      return 0;
    }

    function analyzePokerA(cards) {
      if (!cards.length) return { ok: false, reason: "请选择要出的牌" };

      const sorted = sortedCardsByMode(cards, MODE_POKER_A4);
      const groups = {};
      for (const c of sorted) {
        groups[c.rank] = groups[c.rank] || [];
        groups[c.rank].push(c);
      }
      const ranks = Object.keys(groups).sort((a, b) => (POKER_A_VALUE[a] || 0) - (POKER_A_VALUE[b] || 0));
      const counts = ranks.map((r) => groups[r].length);
      const len = sorted.length;

      if (len === 1) {
        return { ok: true, type: "single", length: 1, mainValue: POKER_A_VALUE[ranks[0]], rankKey: ranks[0], cards: sorted };
      }

      if (len === 2) {
        if (groups.SJ && groups.BJ && ranks.length === 2) {
          return { ok: true, type: "joker_bomb", length: 2, mainValue: 999, rankKey: "JOKER", cards: sorted };
        }
        if (ranks.length === 1 && counts[0] === 2) {
          return { ok: true, type: "pair", length: 2, mainValue: POKER_A_VALUE[ranks[0]], rankKey: ranks[0], cards: sorted };
        }
      }

      if (len === 3 && ranks.length === 1 && counts[0] === 3) {
        return { ok: true, type: "triple_bomb", length: 3, mainValue: POKER_A_VALUE[ranks[0]], rankKey: ranks[0], cards: sorted };
      }

      if (len === 4 && ranks.length === 1 && counts[0] === 4) {
        return { ok: true, type: "quad_bomb", length: 4, mainValue: POKER_A_VALUE[ranks[0]], rankKey: ranks[0], cards: sorted };
      }

      if (len >= 3 && ranks.length === len && counts.every((c) => c === 1)) {
        const sv = ranks.map((r) => POKER_A_STRAIGHT_VALUE[r] || 0);
        const validRange = sv.every((v) => v > 0);
        const consecutive = validRange && sv.every((v, i) => i === 0 || v === sv[i - 1] + 1);
        if (consecutive) {
          return {
            ok: true,
            type: "straight",
            length: len,
            mainValue: sv[sv.length - 1],
            rankKey: ranks[ranks.length - 1],
            cards: sorted
          };
        }
      }

      if (len >= 6 && len % 2 === 0 && counts.every((c) => c === 2)) {
        const sv = ranks.map((r) => POKER_A_STRAIGHT_VALUE[r] || 0);
        const validRange = sv.every((v) => v > 0);
        const consecutive = validRange && sv.every((v, i) => i === 0 || v === sv[i - 1] + 1);
        if (consecutive) {
          return {
            ok: true,
            type: "seq_pair",
            length: len,
            mainValue: sv[sv.length - 1],
            rankKey: ranks[ranks.length - 1],
            cards: sorted
          };
        }
      }

      return { ok: false, reason: "不符合扑克A允许的牌型" };
    }

    function analyzeClassic(cards) {
      if (cards.length !== 1) return { ok: false, reason: "经典模式一次只能出一张牌" };
      const card = cards[0];
      return { ok: true, type: "single", length: 1, mainValue: card.power, rankKey: card.rank, cards: [card] };
    }

    function canBeatClassic(play, lastPlay, mySeat) {
      if (!lastPlay) return true;
      if (lastPlay.seat === mySeat) return true;
      return play.mainValue > (lastPlay.power || 0);
    }

    function canBeatPokerA(play, lastPlay, mySeat) {
      if (!lastPlay) return true;
      if (lastPlay.seat === mySeat) return true;

      const lastType = lastPlay.type || "single";
      const playType = play.type;
      const playBomb = isBombType(playType);
      const lastBomb = isBombType(lastType);

      if (playBomb && !lastBomb) return true;
      if (!playBomb && lastBomb) return false;

      if (playBomb && lastBomb) {
        if (playType === lastType) {
          if (playType === "joker_bomb") return false;
          return play.mainValue > (lastPlay.mainValue || 0);
        }
        return bombLevel(playType) > bombLevel(lastType);
      }

      if (playType !== lastType) return false;
      if ((playType === "straight" || playType === "seq_pair") && play.length !== lastPlay.length) return false;
      return play.mainValue > (lastPlay.mainValue || 0);
    }

    function canCaptureInPokerA(play, lastPlay, activeSeats, mySeat) {
      if (!lastPlay) return false;
      if (lastPlay.seat === mySeat) return false;
      if (!activeSeats.length) return false;
      const expectedSeat = nextSeat(activeSeats, lastPlay.seat);
      if (expectedSeat !== mySeat) return false;
      if (lastPlay.type === "triple_bomb" && play.type === "pair" && play.rankKey === "4") return true;
      if (lastPlay.type === "quad_bomb" && play.type === "triple_bomb" && play.rankKey === "4") return true;
      return false;
    }

    function makeDeck() {
      const suits = ["S", "H", "C", "D"];
      const ranks = ["3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A", "2"];
      const rankPower = {
        "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8,
        "9": 9, "10": 10, J: 11, Q: 12, K: 13, A: 14, "2": 16
      };
      const deck = [];
      for (const r of ranks) {
        for (const s of suits) {
          const id = `${r}${s}`;
          deck.push({
            id,
            rank: r,
            suit: s,
            power: rankPower[r],
            label: `${r}${SUIT_SYMBOL[s]}`,
            red: s === "H" || s === "D"
          });
        }
      }
      deck.push({ id: "SJ", rank: "SJ", suit: "", power: 18, label: "小王", red: false });
      deck.push({ id: "BJ", rank: "BJ", suit: "", power: 20, label: "大王", red: true });
      return deck;
    }

    function shuffle(arr) {
      const a = [...arr];
      const rnd = new Uint32Array(a.length);
      crypto.getRandomValues(rnd);
      for (let i = a.length - 1; i > 0; i -= 1) {
        const j = rnd[i] % (i + 1);
        const tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
      }
      return a;
    }

    function sortedHandCards(handMap) {
      const cards = Object.values(handMap || {});
      return sortedCardsByMode(cards, roomMode(state.room));
    }

    async function fetchRoomOnce() {
      if (!supabase || !state.roomId) return;
      const { data, error } = await supabase
        .from("rooms")
        .select("*")
        .eq("room_id", state.roomId)
        .maybeSingle();

      if (error) {
        showMsg(`拉取房间失败：${friendlyErr(error)}`, true);
        return;
      }

      if (!data) {
        showMsg("房间不存在或已解散", true);
        detachRoomListeners();
        state.roomId = "";
        state.room = null;
        state.hand = {};
        state.selectedCardIds = [];
        roomCodeLabel.textContent = "-";
        history.replaceState({}, "", location.pathname);
        render();
        return;
      }

      state.room = mapRoomRow(data);
      await cleanupGhostSeats();
      await autoFixHost();
      await hostGrantBottomIfNeeded();
    }

    async function fetchHandOnce() {
      if (!supabase || !state.roomId || !state.uid) return;
      const { data, error } = await supabase
        .from("private_hands")
        .select("uid,cards")
        .eq("room_id", state.roomId)
        .eq("uid", state.uid)
        .maybeSingle();

      if (error && error.code !== "PGRST116") {
        showMsg(`拉取手牌失败：${friendlyErr(error)}`, true);
        return;
      }

      state.hand = data?.cards || {};
      state.selectedCardIds = state.selectedCardIds.filter((id) => !!state.hand[id]);
    }

    async function refreshRoomAndHand() {
      if (!state.roomId) return;
      await Promise.all([fetchRoomOnce(), fetchHandOnce()]);
      render();
    }

    function detachRoomListeners() {
      if (state.pollTimer) {
        clearInterval(state.pollTimer);
        state.pollTimer = null;
      }
      for (const fn of state.roomUnsubs) fn();
      state.roomUnsubs = [];
      state.realtimeReady = false;
    }

    function attachRoomListeners() {
      detachRoomListeners();
      if (!state.roomId || !supabase) return;

      refreshRoomAndHand();
      state.pollTimer = setInterval(refreshRoomAndHand, 1500);

      const channel = supabase
        .channel(`room-${state.roomId}-${Date.now()}`)
        .on(
          "postgres_changes",
          { event: "*", schema: "public", table: "rooms", filter: `room_id=eq.${state.roomId}` },
          async () => {
            await fetchRoomOnce();
            render();
          }
        )
        .on(
          "postgres_changes",
          { event: "*", schema: "public", table: "private_hands", filter: `room_id=eq.${state.roomId}` },
          async (payload) => {
            const row = payload.new || payload.old;
            if (!row || row.uid !== state.uid) return;
            await fetchHandOnce();
            render();
          }
        )
        .subscribe((status) => {
          if (status === "SUBSCRIBED") {
            state.realtimeReady = true;
          }
        });

      state.roomUnsubs.push(() => {
        supabase.removeChannel(channel);
      });
    }

    async function mutateRoom(rid, mutator, retries = 8) {
      if (!supabase || !rid) return { committed: false, reason: "bad_request" };

      for (let i = 0; i < retries; i += 1) {
        const { data: row, error: selErr } = await supabase
          .from("rooms")
          .select("*")
          .eq("room_id", rid)
          .maybeSingle();

        if (selErr) throw selErr;
        if (!row) return { committed: false, reason: "not_found" };

        const work = {
          room_id: row.room_id,
          host_uid: row.host_uid,
          status: row.status,
          max_members: row.max_members,
          state: clone(row.state || {}),
          revision: row.revision
        };

        ensureRoomStateShape(work);
        const action = mutator(work);

        if (action === false) return { committed: false, reason: "rejected" };

        if (action === null) {
          const { data: deleted, error: delErr } = await supabase
            .from("rooms")
            .delete()
            .eq("room_id", rid)
            .eq("revision", row.revision)
            .select("room_id");

          if (delErr) throw delErr;
          if (deleted && deleted.length === 1) return { committed: true, deleted: true };
          continue;
        }

        const patch = {
          host_uid: work.host_uid,
          status: work.status,
          max_members: work.max_members,
          state: work.state,
          revision: row.revision + 1,
          updated_at: new Date().toISOString()
        };

        const { data: updated, error: upErr } = await supabase
          .from("rooms")
          .update(patch)
          .eq("room_id", rid)
          .eq("revision", row.revision)
          .select("room_id");

        if (upErr) throw upErr;
        if (updated && updated.length === 1) return { committed: true };
      }

      return { committed: false, reason: "conflict" };
    }

    async function createRoom() {
      if (!supabase) {
        showMsg("请先填写 SUPABASE_CONFIG", true);
        return;
      }
      if (state.roomId) {
        showMsg("请先离开当前房间", true);
        return;
      }
      if (!state.uid) {
        showMsg("尚未登录，请稍后再试", true);
        return;
      }
      const selectedMode = [MODE_CLASSIC, MODE_SOLO_VALIDATE, MODE_POKER_A2, MODE_POKER_A4]
        .includes(gameModeSelect.value)
        ? gameModeSelect.value
        : MODE_CLASSIC;
      const seatCount = selectedMode === MODE_POKER_A4
        ? 4
        : (selectedMode === MODE_POKER_A2 ? 2 : (selectedMode === MODE_SOLO_VALIDATE ? 1 : TABLE_SEAT_COUNT));

      try {
        for (let i = 0; i < 8; i += 1) {
          const code = randRoomCode();
          const row = {
            room_id: code,
            host_uid: state.uid,
            max_members: 9,
            status: "lobby",
            revision: 1,
            state: {
              members: {
                [state.uid]: {
                  nick: state.nick,
                  joinedAt: Date.now()
                }
              },
              gameMode: selectedMode,
              seatCount,
              seats: Object.fromEntries(buildSeatIndexes(seatCount).map((s) => [String(s), null])),
              ready: {},
              publicCounts: {},
              game: null
            }
          };

          const { data, error } = await supabase
            .from("rooms")
            .insert(row)
            .select("room_id");

          if (error) {
            if (error.code === "23505") continue;
            throw error;
          }

          if (data && data.length === 1) {
            state.roomId = code;
            roomCodeInput.value = code;
            roomCodeLabel.textContent = code;
            history.replaceState({}, "", `${location.pathname}?room=${encodeURIComponent(code)}`);
            attachRoomListeners();
            showMsg(`已创建并加入房间 ${code}`);
            log(`已创建房间 ${code}`);
            return;
          }
        }
        showMsg("创建失败：房间码冲突，请重试", true);
      } catch (err) {
        showMsg(`创建失败：${friendlyErr(err)}`, true);
        log(`创建房间异常：${friendlyErr(err)}`);
      }
    }

    async function joinRoom(roomId) {
      if (!supabase) {
        showMsg("请先填写 SUPABASE_CONFIG", true);
        return;
      }
      if (state.roomId) {
        showMsg("请先离开当前房间", true);
        return;
      }
      if (!state.uid) {
        showMsg("尚未登录，请稍后再试", true);
        return;
      }

      const code = (roomId || "").trim().toUpperCase();
      if (!code) {
        showMsg("请输入房间码", true);
        return;
      }

      try {
        const result = await mutateRoom(code, (room) => {
          ensureRoomStateShape(room);
          const members = room.state.members;
          const size = Object.keys(members).length;
          if (!members[state.uid] && size >= room.max_members) return false;
          members[state.uid] = {
            nick: state.nick,
            joinedAt: members[state.uid]?.joinedAt || Date.now()
          };
        });

        if (!result.committed) {
          showMsg("加入失败：房间不存在或已满（最多 9 人）", true);
          return;
        }

        state.roomId = code;
        roomCodeInput.value = code;
        roomCodeLabel.textContent = code;
        history.replaceState({}, "", `${location.pathname}?room=${encodeURIComponent(code)}`);
        attachRoomListeners();
        showMsg("已加入房间");
        log(`已进入房间 ${code}`);
      } catch (err) {
        showMsg(`加入失败：${friendlyErr(err)}`, true);
        log(`加入房间异常：${friendlyErr(err)}`);
      }
    }

    async function leaveRoom() {
      if (!supabase || !state.roomId || !state.uid) return;
      const rid = state.roomId;

      try {
        await mutateRoom(rid, (room) => {
          ensureRoomStateShape(room);
          const members = room.state.members;
          if (!members[state.uid]) return false;

          delete members[state.uid];
          delete room.state.ready[state.uid];
          delete room.state.publicCounts[state.uid];

          for (const s of buildSeatIndexes(room.state.seatCount)) {
            const key = String(s);
            if (room.state.seats[key] === state.uid) room.state.seats[key] = null;
          }

          const left = Object.keys(members);
          if (!left.length) return null;

          if (!members[room.host_uid]) {
            let nextHost = left[0];
            for (const uid of left) {
              const a = members[nextHost]?.joinedAt || Number.MAX_SAFE_INTEGER;
              const b = members[uid]?.joinedAt || Number.MAX_SAFE_INTEGER;
              if (b < a) nextHost = uid;
            }
            room.host_uid = nextHost;
          }
        });

        await supabase
          .from("private_hands")
          .delete()
          .eq("room_id", rid)
          .eq("uid", state.uid);
      } catch (err) {
        showMsg(`离开房间异常：${friendlyErr(err)}`, true);
      }

      detachRoomListeners();
      state.roomId = "";
      state.room = null;
      state.hand = {};
      state.selectedCardIds = [];
      roomCodeLabel.textContent = "-";
      history.replaceState({}, "", location.pathname);
      showMsg("已离开房间");
      render();
    }

    async function cleanupGhostSeats() {
      if (!state.room || !state.roomId) return;
      const room = state.room;
      const members = room.members || {};
      const seats = room.seats || {};
      let needFix = false;

      for (const s of buildSeatIndexes(room.seatCount)) {
        const uid = seats[String(s)];
        if (uid && !members[uid]) {
          needFix = true;
          break;
        }
      }
      if (!needFix) return;

      await mutateRoom(state.roomId, (work) => {
        ensureRoomStateShape(work);
        for (const s of buildSeatIndexes(work.state.seatCount)) {
          const key = String(s);
          const uid = work.state.seats[key];
          if (uid && !work.state.members[uid]) {
            work.state.seats[key] = null;
            delete work.state.ready[uid];
            delete work.state.publicCounts[uid];
          }
        }
      });
    }

    async function autoFixHost() {
      if (!state.room || !state.roomId) return;
      if (state.room.members?.[state.room.hostUid]) return;
      if (!state.room.members?.[state.uid]) return;
      await takeHost();
    }

    async function seatAction(targetSeat) {
      if (!state.roomId) return;
      await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (room.status !== "lobby") return false;
        if (!room.state.members[state.uid]) return false;

        for (const s of buildSeatIndexes(room.state.seatCount)) {
          const key = String(s);
          if (room.state.seats[key] === state.uid) room.state.seats[key] = null;
        }

        if (targetSeat !== null) {
          const key = String(targetSeat);
          if (room.state.seats[key]) return false;
          room.state.seats[key] = state.uid;
        }
      });
    }

    async function toggleReady() {
      if (!state.roomId) return;
      await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (room.status !== "lobby") return false;
        const mySeat = getMySeat(mapRoomRow(room));
        if (mySeat === null) return false;
        room.state.ready[state.uid] = !room.state.ready[state.uid];
      });
    }

    async function takeHost() {
      if (!state.roomId) return;
      await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (!room.state.members[state.uid]) return false;
        if (room.state.members[room.host_uid]) return false;
        room.host_uid = state.uid;
      });
    }

    async function writeHand(uid, cards) {
      if (!supabase || !state.roomId) return;
      const { error } = await supabase
        .from("private_hands")
        .upsert({
          room_id: state.roomId,
          uid,
          cards,
          updated_at: new Date().toISOString()
        }, { onConflict: "room_id,uid" });
      if (error) throw error;
    }

    async function startGame() {
      if (!state.roomId || !state.room) return;
      if (state.room.hostUid !== state.uid || state.room.status !== "lobby") return;

      const mode = roomMode(state.room);
      let activeSeats = [];
      let seatUids = [];
      let hands = null;
      const deck = shuffle(makeDeck());
      let bottom = [];
      let openedCards = [];

      const tx = await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (room.host_uid !== state.uid || room.status !== "lobby") return false;

        activeSeats = activeSeatsFrom(room.state.seats, room.state.seatCount);
        if (mode === MODE_SOLO_VALIDATE) {
          if (activeSeats.length !== 1) return false;
        } else if (mode === MODE_POKER_A2) {
          if (activeSeats.length !== 2) return false;
        } else if (mode === MODE_POKER_A4) {
          if (activeSeats.length !== 4) return false;
        } else if (activeSeats.length < TABLE_MIN_PLAYERS || activeSeats.length > TABLE_MAX_PLAYERS) {
          return false;
        }

        seatUids = activeSeats.map((seat) => room.state.seats[String(seat)]);
        if (seatUids.some((uid) => !room.state.ready[uid])) return false;

        let dealPool = deck;
        if (mode === MODE_POKER_A2) {
          openedCards = deck.slice(0, 10);
          dealPool = deck.slice(10);
          bottom = [];
        } else {
          const bottomCount = mode === MODE_POKER_A4 ? 2 : (mode === MODE_SOLO_VALIDATE ? 0 : getBottomCardCount(activeSeats.length));
          const dealCount = deck.length - bottomCount;
          bottom = deck.slice(dealCount);
          dealPool = deck.slice(0, dealCount);
        }

        hands = Object.fromEntries(seatUids.map((uid) => [uid, {}]));
        room.state.publicCounts = Object.fromEntries(seatUids.map((uid) => [uid, 0]));

        for (let i = 0; i < dealPool.length; i += 1) {
          const uid = seatUids[i % seatUids.length];
          hands[uid][dealPool[i].id] = dealPool[i];
          room.state.publicCounts[uid] += 1;
        }

        const startSeat = activeSeats[Math.floor(Math.random() * activeSeats.length)] || activeSeats[0];
        const bidMap = Object.fromEntries(activeSeats.map((seat) => [String(seat), null]));

        const round = ((room.state.game && room.state.game.round) || 0) + 1;
        room.status = mode === MODE_CLASSIC ? "bidding" : "playing";
        room.state.game = {
          mode,
          round,
          activeSeats,
          bid: mode === MODE_CLASSIC ? {
            currentSeat: startSeat,
            acted: 0,
            bids: bidMap,
            highestBid: 0,
            highestSeat: null
          } : null,
          landlordSeat: null,
          bottomCards: bottom,
          openedCards,
          bottomClaimed: mode !== MODE_CLASSIC,
          turnSeat: startSeat,
          trickLeaderSeat: startSeat,
          passNeed: Math.max(activeSeats.length - 1, 1),
          passStreak: 0,
          lastPlay: null,
          undo: null,
          winnerSeat: null,
          updatedAt: Date.now()
        };

        room.state.ready = {};
      });

      if (!tx.committed) return;
      if (!seatUids.length || !hands) return;

      try {
        await Promise.all(seatUids.map((uid) => writeHand(uid, hands[uid])));
        if (mode === MODE_POKER_A4) {
          log("发牌完成，进入4人扑克A出牌阶段");
        } else if (mode === MODE_POKER_A2) {
          log("发牌完成，进入双人扑克A出牌阶段（已随机抽离10张）");
        } else if (mode === MODE_SOLO_VALIDATE) {
          log("发牌完成，进入单人验证出牌阶段");
        } else {
          log("发牌完成，进入叫分阶段");
        }
      } catch (err) {
        showMsg(`发牌写入失败：${friendlyErr(err)}`, true);
      }
    }

    async function bid(points) {
      const bidVal = Number(points);
      if (![0, 1, 2, 3].includes(bidVal)) return;
      if (!state.roomId) return;

      await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (room.status !== "bidding" || !room.state.game || !room.state.game.bid) return false;
        if ((room.state.game.mode || room.state.gameMode) !== MODE_CLASSIC) return false;

        const mySeat = getMySeat(mapRoomRow(room));
        if (mySeat === null) return false;

        const b = room.state.game.bid;
        if (b.currentSeat !== mySeat) return false;
        if (b.bids[String(mySeat)] !== null) return false;

        b.bids[String(mySeat)] = bidVal;
        b.acted += 1;

        if (bidVal > b.highestBid) {
          b.highestBid = bidVal;
          b.highestSeat = mySeat;
        }

        const activeSeats = (room.state.game.activeSeats || activeSeatsFrom(room.state.seats, room.state.seatCount))
          .filter((seat) => !!room.state.seats[String(seat)]);
        const done = b.acted >= activeSeats.length || bidVal === 3;
        if (!done) {
          b.currentSeat = nextSeat(activeSeats, mySeat);
          room.state.game.updatedAt = Date.now();
          return;
        }

        const landlordSeat = b.highestSeat === null ? activeSeats[0] : b.highestSeat;
        room.state.game.landlordSeat = landlordSeat;
        room.status = "playing";
        room.state.game.turnSeat = landlordSeat;
        room.state.game.trickLeaderSeat = landlordSeat;
        room.state.game.passNeed = Math.max(activeSeats.length - 1, 1);
        room.state.game.passStreak = 0;
        room.state.game.lastPlay = null;
        room.state.game.bottomClaimed = false;
        room.state.game.updatedAt = Date.now();
      });
    }

    async function hostGrantBottomIfNeeded() {
      const room = state.room;
      if (!room || !state.roomId) return;
      if (room.hostUid !== state.uid) return;
      if (room.status !== "playing" || !room.game || room.game.bottomClaimed) return;
      if (room.game.mode === MODE_POKER_A4 || room.game.mode === MODE_POKER_A2 || room.game.mode === MODE_SOLO_VALIDATE) return;

      const landlordSeat = room.game.landlordSeat;
      const landlordUid = room.seats?.[String(landlordSeat)];
      const bottom = room.game.bottomCards || [];
      if (!landlordUid || !bottom.length) return;

      const tx = await mutateRoom(state.roomId, (work) => {
        ensureRoomStateShape(work);
        if (work.host_uid !== state.uid) return false;
        if (work.status !== "playing" || !work.state.game || work.state.game.bottomClaimed) return false;

        const seat = work.state.game.landlordSeat;
        const uid = work.state.seats[String(seat)];
        if (!uid) return false;

        work.state.publicCounts[uid] = (work.state.publicCounts[uid] || 0) + (work.state.game.bottomCards || []).length;
        work.state.game.bottomClaimed = true;
        work.state.game.updatedAt = Date.now();
      });

      if (!tx.committed) return;

      const { data: handRow } = await supabase
        .from("private_hands")
        .select("cards")
        .eq("room_id", state.roomId)
        .eq("uid", landlordUid)
        .maybeSingle();

      const merged = clone(handRow?.cards || {});
      for (const c of bottom) merged[c.id] = c;
      await writeHand(landlordUid, merged);
    }

    async function playSelected() {
      if (!state.roomId || !state.room) return;
      const beforeHand = clone(state.hand || {});
      const selectedIds = [...new Set(state.selectedCardIds)].filter((id) => !!state.hand?.[id]);
      if (!selectedIds.length) {
        showMsg("请先选择要出的牌", true);
        return;
      }

      const mode = roomMode(state.room);
      const selectedCards = selectedIds.map((id) => state.hand[id]);
      const analyzed = (mode === MODE_POKER_A4 || mode === MODE_POKER_A2 || mode === MODE_SOLO_VALIDATE)
        ? analyzePokerA(selectedCards)
        : analyzeClassic(selectedCards);
      if (!analyzed.ok) {
        showMsg(analyzed.reason || "牌型无效", true);
        return;
      }

      const nextHand = clone(state.hand);
      for (const id of selectedIds) delete nextHand[id];

      try {
        await writeHand(state.uid, nextHand);
      } catch (err) {
        showMsg(`手牌更新失败：${friendlyErr(err)}`, true);
        return;
      }

      let capturedCards = [];
      const roomTx = await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (room.status !== "playing" || !room.state.game || !room.state.game.bottomClaimed) return false;

        const prevStatus = room.status;
        const prevPublicCounts = clone(room.state.publicCounts || {});
        const prevGame = clone(room.state.game || {});
        delete prevGame.undo;

        const mySeat = getMySeat(mapRoomRow(room));
        if (mySeat === null || room.state.game.turnSeat !== mySeat) return false;
        const liveMode = room.state.game.mode || room.state.gameMode || MODE_CLASSIC;
        if (liveMode !== mode) return false;

        const liveSeats = (room.state.game.activeSeats || activeSeatsFrom(room.state.seats, room.state.seatCount))
          .filter((seat) => !!room.state.seats[String(seat)]);
        const lastPlay = room.state.game.lastPlay;

        if (liveMode === MODE_POKER_A4 || liveMode === MODE_POKER_A2 || liveMode === MODE_SOLO_VALIDATE) {
          const capture = canCaptureInPokerA(analyzed, lastPlay, liveSeats, mySeat);
          if (!capture && !canBeatPokerA(analyzed, lastPlay, mySeat)) return false;

          room.state.publicCounts[state.uid] = Math.max((room.state.publicCounts[state.uid] || 0) - analyzed.cards.length, 0);

          if (capture) {
            const rawCards = Array.isArray(lastPlay?.cards) ? lastPlay.cards : [lastPlay];
            capturedCards = rawCards.map((x) => normalizeCard(x)).filter(Boolean);
            room.state.publicCounts[state.uid] += capturedCards.length;
          }
        } else {
          if (!canBeatClassic(analyzed, lastPlay, mySeat)) return false;
          room.state.publicCounts[state.uid] = Math.max((room.state.publicCounts[state.uid] || 0) - 1, 0);
        }

        const labels = analyzed.cards.map((c) => c.label || cardPrettyName(c)).join(" ");
        const playRecord = {
          seat: mySeat,
          uid: state.uid,
          type: analyzed.type,
          length: analyzed.length,
          mainValue: analyzed.mainValue,
          rankKey: analyzed.rankKey,
          cards: analyzed.cards,
          label: labels,
          power: analyzed.mainValue,
          at: Date.now()
        };

        room.state.game.lastPlay = playRecord;
        room.state.game.trickLeaderSeat = mySeat;
        room.state.game.passStreak = 0;

        const afterHand = clone(nextHand);
        for (const card of capturedCards) afterHand[card.id] = card;
        room.state.game.undo = {
          kind: "play",
          actorUid: state.uid,
          actorSeat: mySeat,
          beforeHand,
          afterHand,
          prevStatus,
          prevPublicCounts,
          prevGame
        };

        if (room.state.publicCounts[state.uid] === 0) {
          room.status = "finished";
          room.state.game.winnerSeat = mySeat;
          room.state.game.updatedAt = Date.now();
          return;
        }

        room.state.game.turnSeat = nextSeat(liveSeats, mySeat);
        room.state.game.updatedAt = Date.now();
      });

      if (!roomTx.committed) {
        await writeHand(state.uid, beforeHand);
        showMsg("出牌失败，已回滚手牌", true);
        return;
      }

      let finalHand = clone(nextHand);
      if (capturedCards.length) {
        for (const card of capturedCards) finalHand[card.id] = card;
        try {
          await writeHand(state.uid, finalHand);
        } catch (err) {
          showMsg(`捕获牌写入失败：${friendlyErr(err)}`, true);
          return;
        }
      }

      state.hand = finalHand;
      state.selectedCardIds = [];
    }

    async function pass() {
      if (!state.roomId) return;
      await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (room.status !== "playing" || !room.state.game || !room.state.game.bottomClaimed) return false;

        const mySeat = getMySeat(mapRoomRow(room));
        if (mySeat === null || room.state.game.turnSeat !== mySeat) return false;
        if (!room.state.game.lastPlay) return false;
        if (room.state.game.trickLeaderSeat === mySeat) return false;

        room.state.game.passStreak += 1;
        const liveSeats = (room.state.game.activeSeats || []).filter((seat) => !!room.state.seats[String(seat)]);
        const passNeed = room.state.game.passNeed || Math.max(liveSeats.length - 1, 1);

        if (room.state.game.passStreak >= passNeed) {
          room.state.game.turnSeat = room.state.game.trickLeaderSeat;
          room.state.game.lastPlay = null;
          room.state.game.passStreak = 0;
        } else {
          room.state.game.turnSeat = nextSeat(liveSeats, mySeat);
        }
        room.state.game.undo = null;
        room.state.game.updatedAt = Date.now();
      });
      state.selectedCardIds = [];
    }

    async function undoLastPlay() {
      if (!state.roomId || !state.room) return;
      let snapshot = null;

      const tx = await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if ((room.status !== "playing" && room.status !== "finished") || !room.state.game || !room.state.game.undo) return false;
        const undo = room.state.game.undo;
        if (undo.kind !== "play" || undo.actorUid !== state.uid) return false;

        snapshot = clone(undo);
        room.status = undo.prevStatus || "playing";
        room.state.publicCounts = clone(undo.prevPublicCounts || room.state.publicCounts || {});
        room.state.game = clone(undo.prevGame || room.state.game);
        room.state.game.undo = null;
        room.state.game.updatedAt = Date.now();
      });

      if (!tx.committed || !snapshot) {
        showMsg("悔牌失败：当前不可悔牌", true);
        return;
      }

      try {
        await writeHand(state.uid, snapshot.beforeHand || {});
      } catch (err) {
        showMsg(`悔牌后手牌恢复失败：${friendlyErr(err)}`, true);
        return;
      }

      state.hand = clone(snapshot.beforeHand || {});
      state.selectedCardIds = [];
      showMsg("已悔牌");
      log("执行悔牌，已回到上一步出牌前状态");
      render();
    }

    async function restartGame() {
      if (!state.roomId || !state.room) return;
      if (state.room.hostUid !== state.uid) {
        showMsg("仅房主可重开", true);
        return;
      }

      const tx = await mutateRoom(state.roomId, (room) => {
        ensureRoomStateShape(room);
        if (room.host_uid !== state.uid) return false;
        room.status = "lobby";
        room.state.ready = {};
        room.state.publicCounts = {};
        room.state.game = null;
      });

      if (!tx.committed) {
        showMsg("重开失败，请重试", true);
        return;
      }

      try {
        await supabase
          .from("private_hands")
          .delete()
          .eq("room_id", state.roomId);
      } catch (err) {
        showMsg(`清理手牌失败：${friendlyErr(err)}`, true);
        return;
      }

      state.hand = {};
      state.selectedCardIds = [];
      showMsg("已重开，返回大厅");
      log("房主执行重开，对局已重置");
      render();
    }

    function nameOf(uid) {
      const m = state.room?.members?.[uid];
      return m?.nick || uid?.slice(0, 6) || "-";
    }

    function renderSeats() {
      const room = state.room;
      if (!room) {
        seatsWrap.innerHTML = "";
        return;
      }

      const mySeat = getMySeat(room);
      const seatIndexes = buildSeatIndexes(room.seatCount);
      seatsWrap.innerHTML = seatIndexes.map((seat) => {
        const uid = room.seats?.[String(seat)] || null;
        const isMine = uid && uid === state.uid;
        const label = uid ? escapeHtml(nameOf(uid)) : "空位";
        const ready = uid && room.ready?.[uid] ? "<span class='pill'>已准备</span>" : "";
        const landlord = room.game?.landlordSeat === seat ? "<span class='pill'>地主</span>" : "";
        const turn = room.game?.turnSeat === seat && room.status === "playing" ? "<span class='pill'>出牌中</span>" : "";
        const count = uid ? `<div class='small'>剩余牌：${room.publicCounts?.[uid] ?? "-"}</div>` : "";
        const btn = uid
          ? (isMine ? `<button data-seat='stand'>离座</button>` : "")
          : `<button data-seat='${seat}'>入座</button>`;
        const turnClass = room.game?.turnSeat === seat && room.status === "playing" ? "turning" : "";

        return `
          <div class="seat ${mySeat === seat ? "you" : ""} ${turnClass}">
            <div><strong>${seat + 1} 号位</strong></div>
            <div style="margin-top: 4px;">${label}</div>
            <div style="margin-top: 6px;">${ready}${landlord}${turn}</div>
            <div style="margin-top: 6px;">${count}</div>
            <div style="margin-top: 8px;">${btn}</div>
          </div>
        `;
      }).join("");

      seatsWrap.querySelectorAll("button[data-seat]").forEach((btn) => {
        btn.addEventListener("click", async () => {
          const v = btn.dataset.seat;
          if (v === "stand") {
            await seatAction(null);
            return;
          }
          await seatAction(Number(v));
        });
      });
    }

    function renderRoomInfo() {
      if (!state.room) {
        gameModeSelect.disabled = false;
        roomInfo.innerHTML = "尚未加入房间";
        return;
      }

      const room = state.room;
      const members = Object.entries(room.members || {}).sort((a, b) => (a[1].joinedAt || 0) - (b[1].joinedAt || 0));
      const seated = activeSeatsFrom(room.seats, room.seatCount).length;
      const mode = roomMode(room);
      const startRange = mode === MODE_POKER_A4
        ? "4"
        : (mode === MODE_POKER_A2 ? "2" : (mode === MODE_SOLO_VALIDATE ? "1" : `${TABLE_MIN_PLAYERS}-${TABLE_MAX_PLAYERS}`));
      gameModeSelect.value = room.gameMode || MODE_CLASSIC;
      gameModeSelect.disabled = true;
      roomInfo.innerHTML = `
        <div>状态：<span class="pill">${escapeHtml(room.status || "-")}</span></div>
        <div>房主：${escapeHtml(nameOf(room.hostUid))}</div>
        <div>模式：${escapeHtml(modeLabel(room.gameMode))}</div>
        <div>在线人数：${members.length}/${room.maxMembers || 9}</div>
        <div>入座人数：${seated}（可开局范围：${startRange}）</div>
        <div>同步：${state.realtimeReady ? "实时通道" : "轮询"}</div>
        <div style="margin-top: 6px;">成员：${members.map(([uid, v]) => {
          const host = uid === room.hostUid ? "(房主)" : "";
          return `${escapeHtml(v.nick || uid.slice(0, 6))}${host}`;
        }).join("、")}</div>
      `;
    }

    function renderGame() {
      const room = state.room;
      if (!room || !room.game) {
        gameInfo.textContent = "等待开局";
        bidWrap.style.display = "none";
        playActions.style.display = "none";
        return;
      }

      const mySeat = getMySeat(room);
      const game = room.game;
      const mode = roomMode(room);

      if (room.status === "bidding" && mode === MODE_CLASSIC) {
        const curUid = room.seats?.[String(game.bid.currentSeat)];
        const bids = game.bid.bids || {};
        const bidLabels = (game.activeSeats || []).map((seat) => `${seat + 1}号(${bids[String(seat)] ?? "-"})`).join(" / ");
        gameInfo.innerHTML = `
          <div>阶段：叫分</div>
          <div>当前：${escapeHtml(nameOf(curUid))}</div>
          <div>叫分记录：${escapeHtml(bidLabels || "-")}</div>
        `;
        bidWrap.style.display = mySeat === game.bid.currentSeat ? "flex" : "none";
        playActions.style.display = "none";
      } else if (room.status === "playing") {
        const last = game.lastPlay ? `${game.lastPlay.label}（${nameOf(game.lastPlay.uid)}）` : "无（新一轮）";
        const landlordUid = room.seats?.[String(game.landlordSeat)];
        const turnUid = room.seats?.[String(game.turnSeat)];
        if (mode === MODE_POKER_A4) {
          gameInfo.innerHTML = `
            <div>阶段：4人扑克A出牌</div>
            <div>当前：${escapeHtml(nameOf(turnUid))}</div>
            <div>最近牌：${escapeHtml(last)}</div>
          `;
        } else if (mode === MODE_POKER_A2) {
          gameInfo.innerHTML = `
            <div>阶段：双人扑克A出牌</div>
            <div>当前：${escapeHtml(nameOf(turnUid))}</div>
            <div>最近牌：${escapeHtml(last)}</div>
            <div>开牌：已随机抽离 ${(game.openedCards || []).length || 10} 张</div>
          `;
        } else if (mode === MODE_SOLO_VALIDATE) {
          gameInfo.innerHTML = `
            <div>阶段：单人验证出牌</div>
            <div>当前：${escapeHtml(nameOf(turnUid))}</div>
            <div>最近牌：${escapeHtml(last)}</div>
          `;
        } else {
          gameInfo.innerHTML = `
            <div>阶段：出牌</div>
            <div>地主：${escapeHtml(nameOf(landlordUid))}</div>
            <div>当前：${escapeHtml(nameOf(turnUid))}</div>
            <div>最近牌：${escapeHtml(last)}</div>
            <div>底牌状态：${game.bottomClaimed ? "已发放" : "房主发放中"}</div>
          `;
        }
        bidWrap.style.display = "none";
        playActions.style.display = mySeat === game.turnSeat && game.bottomClaimed ? "flex" : "none";
      } else if (room.status === "finished") {
        const winnerUid = room.seats?.[String(game.winnerSeat)];
        const range = mode === MODE_POKER_A4 ? "4" : (mode === MODE_POKER_A2 ? "2" : (mode === MODE_SOLO_VALIDATE ? "1" : `${TABLE_MIN_PLAYERS}-${TABLE_MAX_PLAYERS}`));
        gameInfo.innerHTML = `
          <div>阶段：已结束</div>
          <div>胜者：${escapeHtml(nameOf(winnerUid))}</div>
          <div class="small">房主可重新开始（${range} 人入座并准备）</div>
        `;
        bidWrap.style.display = "none";
        playActions.style.display = "none";
      }
    }

    function renderHand() {
      const cards = sortedHandCards(state.hand);
      if (!cards.length) {
        handCards.innerHTML = '<span class="small muted">暂无手牌</span>';
        return;
      }

      const canPlay = state.room?.status === "playing"
        && state.room?.game?.bottomClaimed
        && getMySeat(state.room) === state.room?.game?.turnSeat;

      handCards.innerHTML = cards.map((c, idx) => {
        const id = escapeHtml(c.id);
        const title = escapeHtml(cardPrettyName(c));
        const src = cardImageUrl(c);
        const selected = state.selectedCardIds.includes(c.id) ? "selected" : "";
        return `<button class="card-btn ${selected}" data-card="${id}" title="${title}" style="z-index:${idx + 1}" ${canPlay ? "" : "disabled"}><img class="card-img" src="${src}" alt="${title}" /></button>`;
      }).join("");

      handCards.querySelectorAll("button[data-card]").forEach((btn) => {
        btn.addEventListener("click", async () => {
          if (!canPlay) return;
          const id = btn.dataset.card;
          if (state.selectedCardIds.includes(id)) {
            state.selectedCardIds = state.selectedCardIds.filter((x) => x !== id);
          } else {
            state.selectedCardIds = [...state.selectedCardIds, id];
          }
          renderHand();
          renderButtons();
        });
      });
    }

    function renderButtons() {
      const room = state.room;
      const mySeat = getMySeat(room);
      const isReady = room?.ready?.[state.uid];
      const isHost = room?.hostUid === state.uid;
      const mode = roomMode(room);

      toggleReadyBtn.disabled = !(room && room.status === "lobby" && mySeat !== null);
      toggleReadyBtn.textContent = isReady ? "取消准备" : "准备";

      const activeSeats = room ? activeSeatsFrom(room.seats, room.seatCount) : [];
      const seatOk = mode === MODE_POKER_A4
        ? activeSeats.length === 4
        : (mode === MODE_POKER_A2
          ? activeSeats.length === 2
          : (mode === MODE_SOLO_VALIDATE
          ? activeSeats.length === 1
          : (activeSeats.length >= TABLE_MIN_PLAYERS && activeSeats.length <= TABLE_MAX_PLAYERS)));
      const readyOk = seatOk && activeSeats.every((seat) => room.ready?.[room.seats[String(seat)]]);
      startBtn.disabled = !(room && isHost && room.status === "lobby" && readyOk);
      hostTakeoverBtn.disabled = !(room && room.members && !room.members[room.hostUid] && room.members[state.uid]);
      playSelectedBtn.disabled = !(room && room.status === "playing" && mySeat === room.game?.turnSeat && room.game?.bottomClaimed && state.selectedCardIds.length > 0);
      passBtn.disabled = !(room && room.status === "playing" && mySeat === room.game?.turnSeat && room.game?.lastPlay && room.game?.trickLeaderSeat !== mySeat);
      undoBtn.disabled = !(room && (room.status === "playing" || room.status === "finished") && room.game?.undo && room.game.undo.actorUid === state.uid);
      restartBtn.disabled = !(room && room.hostUid === state.uid);
    }

    function renderPlayedWindow() {
      const room = state.room;
      if (!room || !room.game) {
        playedNow.innerHTML = '<span class="small muted">等待对局开始</span>';
        return;
      }

      const last = room.game.lastPlay;
      if (!last) {
        playedNow.innerHTML = '<span class="small muted">上一手为空（新一轮开始）</span>';
        return;
      }

      const cards = (Array.isArray(last.cards) ? last.cards : [last]).map((x) => normalizeCard(x)).filter(Boolean);
      if (!cards.length) {
        playedNow.innerHTML = '<span class="small muted">上一手数据不可用</span>';
        return;
      }

      const who = escapeHtml(last.uid === state.uid ? "你" : nameOf(last.uid));
      playedNow.innerHTML = cards.map((card) => {
        const src = cardImageUrl(card);
        const alt = escapeHtml(cardPrettyName(card));
        return `
          <div class="played-chip">
            <img class="played-card" src="${src}" alt="${alt}" />
            <div class="played-cap">${who}</div>
          </div>
        `;
      }).join("");
    }

    function renderRulesInfo() {
      const mode = state.room ? roomMode(state.room) : (gameModeSelect.value || MODE_CLASSIC);
      rulesInfo.textContent = modeRulesText(mode);
    }

    function render() {
      renderRoomInfo();
      renderSeats();
      renderGame();
      renderHand();
      renderPlayedWindow();
      renderRulesInfo();
      renderButtons();
    }

    let authInitStarted = false;
    function unlockGateAndStart() {
      document.body.classList.remove("locked");
      gateOverlay.style.display = "none";
      gateMsg.textContent = "";
      if (!authInitStarted) {
        authInitStarted = true;
        initAuth();
      }
    }

    function lockGate() {
      document.body.classList.add("locked");
      gateOverlay.style.display = "flex";
      gateInput.value = "";
      gateMsg.textContent = "";
      setTimeout(() => gateInput.focus(), 0);
    }

    function submitGate() {
      const code = gateInput.value.trim();
      if (code !== GATE_CODE) {
        gateMsg.textContent = "访问码错误，请重试。";
        return;
      }
      unlockGateAndStart();
    }

    async function initAuth() {
      if (!supabase) {
        authStatus.textContent = "未配置 Supabase";
        showMsg("请先在 index.html 填写 SUPABASE_CONFIG（url + publishableKey）", true);
        return;
      }

      authStatus.textContent = "匿名登录中...";

      const { data: listener } = supabase.auth.onAuthStateChange((_event, session) => {
        if (session?.user) {
          state.uid = session.user.id;
          authStatus.textContent = `匿名登录：${state.uid.slice(0, 8)}...`;
          render();
        }
      });

      state.authUnsub = () => listener.subscription.unsubscribe();

      const { data: sessData, error: sessErr } = await supabase.auth.getSession();
      if (sessErr) {
        authStatus.textContent = `获取会话失败：${friendlyErr(sessErr)}`;
        showMsg(`登录失败：${friendlyErr(sessErr)}`, true);
        return;
      }

      if (!sessData.session) {
        const { data, error } = await supabase.auth.signInAnonymously();
        if (error) {
          authStatus.textContent = `匿名登录失败：${friendlyErr(error)}`;
          showMsg(`匿名登录失败：${friendlyErr(error)}`, true);
          return;
        }
        state.uid = data.user?.id || "";
      } else {
        state.uid = sessData.session.user.id;
      }

      authStatus.textContent = `匿名登录：${state.uid.slice(0, 8)}...`;
      const roomFromUrl = new URL(location.href).searchParams.get("room");
      if (roomFromUrl && !state.roomId) {
        await joinRoom(roomFromUrl);
      }
    }

    saveNickBtn.addEventListener("click", async () => {
      const nextNick = nicknameInput.value.trim().slice(0, 12);
      if (!nextNick) return;
      state.nick = nextNick;
      localStorage.setItem("ddz_nick", nextNick);

      if (state.roomId && state.uid) {
        await mutateRoom(state.roomId, (room) => {
          ensureRoomStateShape(room);
          if (!room.state.members[state.uid]) return false;
          room.state.members[state.uid].nick = nextNick;
        });
      }
      log(`昵称已更新为 ${nextNick}`);
    });

    gameModeSelect.addEventListener("change", () => {
      if (!state.room) renderRulesInfo();
    });

    createRoomBtn.addEventListener("click", async () => {
      await createRoom();
    });

    joinRoomBtn.addEventListener("click", async () => {
      await joinRoom(roomCodeInput.value);
    });

    leaveRoomBtn.addEventListener("click", async () => {
      await leaveRoom();
    });

    copyLinkBtn.addEventListener("click", async () => {
      if (!state.roomId) return;
      const link = `${location.origin}${location.pathname}?room=${state.roomId}`;
      await navigator.clipboard.writeText(link);
      showMsg("邀请链接已复制");
    });

    toggleReadyBtn.addEventListener("click", async () => {
      await toggleReady();
    });

    startBtn.addEventListener("click", async () => {
      await startGame();
    });

    undoBtn.addEventListener("click", async () => {
      await undoLastPlay();
    });

    restartBtn.addEventListener("click", async () => {
      await restartGame();
    });

    hostTakeoverBtn.addEventListener("click", async () => {
      await takeHost();
    });

    bidWrap.querySelectorAll("button[data-bid]").forEach((btn) => {
      btn.addEventListener("click", async () => {
        await bid(Number(btn.dataset.bid));
      });
    });

    playSelectedBtn.addEventListener("click", async () => {
      await playSelected();
    });

    passBtn.addEventListener("click", async () => {
      await pass();
    });

    gateBtn.addEventListener("click", submitGate);
    gateInput.addEventListener("keydown", (evt) => {
      if (evt.key === "Enter") submitGate();
    });

    window.addEventListener("beforeunload", () => {
      if (state.pollTimer) clearInterval(state.pollTimer);
      for (const fn of state.roomUnsubs) fn();
      if (state.authUnsub) state.authUnsub();
    });

    window.__ddzState = state;
    render();
    lockGate();
  </script>
</body>
</html>
